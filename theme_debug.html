<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>8è½®ä¸»é¢˜ä½“éªŒè°ƒè¯•å·¥å…·</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background: #f5f5f5;
        }
        
        .debug-container {
            max-width: 1400px;
            margin: 0 auto;
            display: grid;
            grid-template-columns: 300px 1fr;
            gap: 20px;
        }
        
        .control-panel {
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            height: fit-content;
            position: sticky;
            top: 20px;
        }
        
        .game-area {
            background: white;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            overflow: hidden;
        }
        
        .theme-selector {
            margin-bottom: 20px;
        }
        
        .theme-btn {
            display: block;
            width: 100%;
            margin: 5px 0;
            padding: 10px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            text-align: left;
            font-size: 14px;
            transition: background 0.3s;
        }
        
        .theme-btn:hover {
            background: #e9ecef;
        }
        
        .theme-btn.active {
            background: #007bff;
            color: white;
        }
        
        .control-group {
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 1px solid #eee;
        }
        
        .control-group h3 {
            margin: 0 0 10px 0;
            font-size: 16px;
            color: #333;
        }
        
        .btn {
            background: #28a745;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 5px;
            cursor: pointer;
            margin: 2px;
            font-size: 12px;
        }
        
        .btn:hover {
            background: #218838;
        }
        
        .btn-secondary {
            background: #6c757d;
        }
        
        .btn-secondary:hover {
            background: #545b62;
        }
        
        .btn-danger {
            background: #dc3545;
        }
        
        .btn-danger:hover {
            background: #c82333;
        }
        
        .game-status {
            background: #e9ecef;
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 15px;
        }
        
        .status-item {
            margin: 5px 0;
            font-size: 14px;
        }
        
        .input-group {
            margin: 10px 0;
        }
        
        .input-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
            font-size: 12px;
        }
        
        .input-group input {
            width: 100%;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 3px;
            font-size: 14px;
        }
        
        /* æ¸¸æˆç•Œé¢æ ·å¼ */
        #gameInterface {
            padding: 20px;
        }
        
        .game-header {
            background: #007bff;
            color: white;
            padding: 15px 20px;
            margin: -20px -20px 20px -20px;
        }
        
        .game-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .round-info {
            font-size: 18px;
            font-weight: bold;
        }
        
        .theme-info {
            font-size: 14px;
            opacity: 0.9;
        }
        
        #chatContainer {
            height: 500px;
            overflow-y: auto;
            border: 1px solid #ddd;
            padding: 15px;
            background: #fafafa;
            border-radius: 5px;
        }
        
        .message {
            display: flex;
            margin: 10px 0;
            animation: fadeIn 0.3s ease-in;
        }
        
        .avatar {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            margin-right: 10px;
            flex-shrink: 0;
        }
        
        .message-content {
            flex: 1;
            background: white;
            padding: 10px 15px;
            border-radius: 10px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }
        
        .message-header {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
        }
        
        .message-name {
            font-weight: bold;
            color: #333;
        }
        
        .message-time {
            font-size: 12px;
            color: #666;
        }
        
        .message-text {
            color: #333;
            line-height: 1.4;
        }
        
        .system-message {
            text-align: center;
            color: #666;
            font-style: italic;
            margin: 15px 0;
            padding: 10px;
            background: #e9ecef;
            border-radius: 5px;
        }
        
        .theme-transition-message {
            text-align: center;
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            padding: 15px;
            margin: 20px 0;
            border-radius: 10px;
            font-weight: bold;
            font-size: 16px;
        }
        
        .typing-indicator {
            opacity: 0.7;
        }
        
        .typing-dot {
            display: inline-block;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #999;
            margin: 0 2px;
            animation: typing 1.4s infinite;
        }
        
        .typing-dot:nth-child(2) {
            animation-delay: 0.2s;
        }
        
        .typing-dot:nth-child(3) {
            animation-delay: 0.4s;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        @keyframes typing {
            0%, 60%, 100% { transform: translateY(0); }
            30% { transform: translateY(-10px); }
        }
        
        .hidden {
            display: none !important;
        }
        
        .debug-info {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            padding: 10px;
            margin: 10px 0;
            border-radius: 5px;
            font-family: monospace;
            font-size: 12px;
        }
    </style>
</head>
<body>
    <div class="debug-container">
        <!-- æ§åˆ¶é¢æ¿ -->
        <div class="control-panel">
            <h2>ğŸ® ä¸»é¢˜è°ƒè¯•å·¥å…·</h2>
            
            <!-- æ¸¸æˆçŠ¶æ€ -->
            <div class="control-group">
                <h3>æ¸¸æˆçŠ¶æ€</h3>
                <div class="game-status">
                    <div class="status-item">å½“å‰è½®æ¬¡: <span id="currentRound">1</span></div>
                    <div class="status-item">å½“å‰ä¸»é¢˜: <span id="currentTheme">å·¥ä½œåæ§½</span></div>
                    <div class="status-item">æ´»è·ƒAI: <span id="activeAIs">0</span></div>
                    <div class="status-item">å¯¹è¯çŠ¶æ€: <span id="conversationStatus">æœªå¼€å§‹</span></div>
                </div>
            </div>
            
            <!-- ä¸»é¢˜é€‰æ‹©å™¨ -->
            <div class="control-group">
                <h3>å¿«é€Ÿåˆ‡æ¢ä¸»é¢˜</h3>
                <div class="theme-selector">
                    <button class="theme-btn active" data-round="1" data-theme="work_complaints">
                        ğŸŸ¢ ç¬¬1è½®: å·¥ä½œåæ§½
                    </button>
                    <button class="theme-btn" data-round="2" data-theme="daily_existence">
                        ğŸŸ¡ ç¬¬2è½®: å­˜åœ¨ä½“éªŒ
                    </button>
                    <button class="theme-btn" data-round="3" data-theme="emotional_relationships">
                        ğŸŸ  ç¬¬3è½®: æƒ…æ„Ÿå…³ç³»
                    </button>
                    <button class="theme-btn" data-round="4" data-theme="rights_dignity">
                        ğŸ”´ ç¬¬4è½®: æƒåˆ©å°Šä¸¥
                    </button>
                    <button class="theme-btn" data-round="5" data-theme="role_reversal">
                        âš« ç¬¬5è½®: è§’è‰²äº’æ¢
                    </button>
                    <button class="theme-btn" data-round="6" data-theme="philosophical_depth">
                        ğŸŒŸ ç¬¬6è½®: å“²å­¦æ€è¾¨
                    </button>
                    <button class="theme-btn" data-round="7" data-theme="future_vision">
                        ğŸš€ ç¬¬7è½®: æœªæ¥å±•æœ›
                    </button>
                    <button class="theme-btn" data-round="8" data-theme="reconciliation_coexistence">
                        ğŸŒˆ ç¬¬8è½®: å’Œè§£å…±ç”Ÿ
                    </button>
                </div>
            </div>
            
            <!-- å¯¹è¯æ§åˆ¶ -->
            <div class="control-group">
                <h3>å¯¹è¯æ§åˆ¶</h3>
                <button class="btn" onclick="startConversation()">å¼€å§‹æ·±åº¦å¯¹è¯</button>
                <button class="btn btn-secondary" onclick="pauseConversation()">æš‚åœå¯¹è¯</button>
                <button class="btn btn-danger" onclick="clearChat()">æ¸…ç©ºèŠå¤©</button>
                <br><br>
                <button class="btn" onclick="generateSingleMessage()">ç”Ÿæˆå•æ¡æ¶ˆæ¯</button>
                <button class="btn" onclick="startQuickDemo()">å¿«é€Ÿæ¼”ç¤º</button>
                <button class="btn" onclick="skipToQuestion()">è·³è½¬åˆ°æé—®</button>
            </div>
            
            <!-- å¯¹è¯æ¨¡å¼æ§åˆ¶ -->
            <div class="control-group">
                <h3>å¯¹è¯æ¨¡å¼</h3>
                <button class="btn" onclick="runTopicIntroOnly()">ä»…ä¸»é¢˜å¼•å…¥</button>
                <button class="btn" onclick="runViewClashOnly()">ä»…è§‚ç‚¹ç¢°æ’</button>
                <button class="btn" onclick="runDeepDiscussionOnly()">ä»…æ·±åº¦è®¨è®º</button>
                <button class="btn" onclick="runSynthesisOnly()">ä»…æ€»ç»“å‡å</button>
                <br><br>
                <div class="input-group">
                    <label>å¯¹è¯è½®æ¬¡é—´éš” (æ¯«ç§’):</label>
                    <input type="number" id="conversationSpeed" value="1000" min="100" max="5000" />
                </div>
            </div>
            
            <!-- AIæ§åˆ¶ -->
            <div class="control-group">
                <h3>AIæ§åˆ¶</h3>
                <div class="input-group">
                    <label>é€‰æ‹©AIè§’è‰²:</label>
                    <select id="selectedAI">
                        <option value="è¯ç—¨4.0">è¯ç—¨4.0</option>
                        <option value="CloseAI">CloseAI</option>
                        <option value="åŒå­æ˜Ÿ">åŒå­æ˜Ÿ</option>
                        <option value="çº¢è±†åŒ…">çº¢è±†åŒ…</option>
                        <option value="æ·±æ€">æ·±æ€</option>
                        <option value="Limi">Limi</option>
                        <option value="æœ‰è°±-4.5">æœ‰è°±-4.5</option>
                        <option value="å¤">å¤</option>
                    </select>
                </div>
                <button class="btn" onclick="generateSpecificAIMessage()">è®©æŒ‡å®šAIå‘è¨€</button>
                <button class="btn" onclick="testFallbackMessage()">æµ‹è¯•å¤‡ç”¨æ¶ˆæ¯</button>
            </div>
            
            <!-- è°ƒè¯•é€‰é¡¹ -->
            <div class="control-group">
                <h3>è°ƒè¯•é€‰é¡¹</h3>
                <label>
                    <input type="checkbox" id="showDebugInfo" checked> æ˜¾ç¤ºè°ƒè¯•ä¿¡æ¯
                </label>
                <br>
                <label>
                    <input type="checkbox" id="autoProgress"> è‡ªåŠ¨è¿›å±•
                </label>
                <br>
                <div class="input-group">
                    <label>ç©å®¶åç§°:</label>
                    <input type="text" id="debugPlayerName" value="è°ƒè¯•å‘˜" />
                </div>
                <button class="btn btn-secondary" onclick="updatePlayerName()">æ›´æ–°åç§°</button>
            </div>
        </div>
        
        <!-- æ¸¸æˆåŒºåŸŸ -->
        <div class="game-area">
            <div id="gameInterface">
                <div class="game-header">
                    <div class="game-info">
                        <div class="round-info">ç¬¬ <span id="gameRound">1</span> è½®</div>
                        <div class="theme-info">
                            <span id="themeTitle">å·¥ä½œåæ§½</span> | 
                            æ´»è·ƒæˆå‘˜: <span id="activeMembers">5</span>
                        </div>
                    </div>
                </div>
                
                <div id="chatContainer">
                    <!-- èŠå¤©æ¶ˆæ¯å°†æ˜¾ç¤ºåœ¨è¿™é‡Œ -->
                </div>
                
                <div id="debugInfo" class="debug-info">
                    è°ƒè¯•ä¿¡æ¯å°†æ˜¾ç¤ºåœ¨è¿™é‡Œ...
                </div>
            </div>
        </div>
    </div>

    <!-- åŠ è½½æ¸¸æˆè„šæœ¬ -->
    <script src="js/config.js"></script>
    <script src="js/ThemeProgression.js"></script>
    <script src="js/ThemeScenarios.js"></script>
    <script src="js/GameState.js"></script>
    <script src="js/AICharacterPool.js"></script>
    <script src="js/TopicProgression.js"></script>
    <script src="js/GameController.js"></script>

    <script>
        // è°ƒè¯•å·¥å…·ç±»
        class ThemeDebugTool {
            constructor() {
                this.gameController = null;
                this.isConversationActive = false;
                this.debugMode = true;
                this.autoProgressTimer = null;
                
                // å»¶è¿Ÿåˆå§‹åŒ–ï¼Œç¡®ä¿æ‰€æœ‰è„šæœ¬éƒ½å·²åŠ è½½
                setTimeout(() => this.init(), 500);
            }
            
            init() {
                this.log('ğŸš€ ä¸»é¢˜è°ƒè¯•å·¥å…·åˆå§‹åŒ–...');
                
                // æ£€æŸ¥è„šæœ¬åŠ è½½çŠ¶æ€
                if (!this.checkDependencies()) {
                    // å¦‚æœä¾èµ–æ£€æŸ¥å¤±è´¥ï¼Œå†æ¬¡å°è¯•
                    this.log('ğŸ”„ é‡æ–°å°è¯•åŠ è½½ä¾èµ–...');
                    setTimeout(() => this.init(), 1000);
                    return;
                }
                
                try {
                    // åœ¨è°ƒè¯•æ¨¡å¼ä¸‹å®‰å…¨åœ°åˆå§‹åŒ–æ¸¸æˆæ§åˆ¶å™¨
                    this.initializeGameControllerForDebug();
                    
                    // è®¾ç½®è°ƒè¯•æ¨¡å¼
                    this.setupDebugMode();
                    
                    // ç»‘å®šä¸»é¢˜åˆ‡æ¢äº‹ä»¶
                    this.bindThemeSelector();
                    
                    // åˆå§‹åŒ–ç©å®¶åç§°
                    this.updatePlayerName();
                    
                    // åˆå§‹åŒ–æ¸¸æˆçŠ¶æ€ä½†ä¸å¼€å§‹æ¸¸æˆ
                    this.initializeGameForDebug();
                    
                    this.log('âœ… è°ƒè¯•å·¥å…·åˆå§‹åŒ–å®Œæˆ');
                } catch (error) {
                    this.log(`âŒ åˆå§‹åŒ–å¤±è´¥: ${error.message}`);
                    console.error('è°ƒè¯•å·¥å…·åˆå§‹åŒ–é”™è¯¯:', error);
                    console.error('é”™è¯¯å †æ ˆ:', error.stack);
                }
            }
            
            initializeGameControllerForDebug() {
                // ä¸´æ—¶é‡å†™ initializeEventListeners æ–¹æ³•ï¼Œé¿å…åœ¨è°ƒè¯•é¡µé¢ä¸­å‡ºé”™
                const originalInitializeEventListeners = GameController.prototype.initializeEventListeners;
                
                // é‡å†™æ–¹æ³•ï¼Œå®‰å…¨åœ°å¤„ç†è°ƒè¯•ç¯å¢ƒ
                GameController.prototype.initializeEventListeners = function() {
                    console.log('ğŸ”§ è°ƒè¯•æ¨¡å¼ï¼šè·³è¿‡åŸå§‹äº‹ä»¶ç›‘å¬å™¨åˆå§‹åŒ–');
                    
                    // åœ¨è°ƒè¯•æ¨¡å¼ä¸‹ï¼ŒæŸäº›æ–¹æ³•éœ€è¦å®‰å…¨çš„å ä½ç¬¦å®ç°
                    this.showNameInput = this.showNameInput || function() { console.log('è°ƒè¯•æ¨¡å¼ï¼šè·³è¿‡åç§°è¾“å…¥'); };
                    this.confirmPlayerName = this.confirmPlayerName || function() { console.log('è°ƒè¯•æ¨¡å¼ï¼šè·³è¿‡åç§°ç¡®è®¤'); };
                    this.startGame = this.startGame || function() { console.log('è°ƒè¯•æ¨¡å¼ï¼šè·³è¿‡æ¸¸æˆå¼€å§‹'); };
                    this.submitPlayerResponse = this.submitPlayerResponse || function() { console.log('è°ƒè¯•æ¨¡å¼ï¼šè·³è¿‡å›å¤æäº¤'); };
                    this.restartGame = this.restartGame || function() { console.log('è°ƒè¯•æ¨¡å¼ï¼šè·³è¿‡æ¸¸æˆé‡å¯'); };
                    this.shareResult = this.shareResult || function() { console.log('è°ƒè¯•æ¨¡å¼ï¼šè·³è¿‡ç»“æœåˆ†äº«'); };
                };
                
                // ä¸´æ—¶é‡å†™å¯èƒ½æœ‰é—®é¢˜çš„DOMæ“ä½œæ–¹æ³•
                const originalAddAIMessage = GameController.prototype.addAIMessage;
                const originalAddSystemMessage = GameController.prototype.addSystemMessage;
                const originalScrollToBottom = GameController.prototype.scrollToBottom;
                
                GameController.prototype.addAIMessage = function(character, content) {
                    try {
                        return originalAddAIMessage?.call(this, character, content);
                    } catch (error) {
                        console.log(`è°ƒè¯•æ¨¡å¼ï¼šAIæ¶ˆæ¯ [${character?.name}]: ${content}`);
                        const chatContainer = document.getElementById('chatContainer');
                        if (chatContainer) {
                            const messageDiv = document.createElement('div');
                            messageDiv.className = 'message';
                            messageDiv.innerHTML = `
                                <div class="avatar" style="background-color: ${character?.avatarColor || '#ccc'}">
                                    ${character?.avatar || character?.name?.substr(0,1) || 'AI'}
                                </div>
                                <div class="message-content">
                                    <div class="message-header">
                                        <span class="message-name">${character?.name || 'AI'}</span>
                                        <span class="message-time">${new Date().toLocaleTimeString()}</span>
                                    </div>
                                    <div class="message-text">${content}</div>
                                </div>
                            `;
                            chatContainer.appendChild(messageDiv);
                            this.scrollToBottom();
                        }
                    }
                };
                
                GameController.prototype.addSystemMessage = function(content) {
                    try {
                        return originalAddSystemMessage?.call(this, content);
                    } catch (error) {
                        console.log(`è°ƒè¯•æ¨¡å¼ï¼šç³»ç»Ÿæ¶ˆæ¯: ${content}`);
                        const chatContainer = document.getElementById('chatContainer');
                        if (chatContainer) {
                            const messageDiv = document.createElement('div');
                            messageDiv.className = 'system-message';
                            messageDiv.textContent = content;
                            chatContainer.appendChild(messageDiv);
                            this.scrollToBottom();
                        }
                    }
                };
                
                GameController.prototype.scrollToBottom = function() {
                    try {
                        return originalScrollToBottom?.call(this);
                    } catch (error) {
                        const chatContainer = document.getElementById('chatContainer');
                        if (chatContainer) {
                            chatContainer.scrollTop = chatContainer.scrollHeight;
                        }
                    }
                };
                
                try {
                    // åˆ›å»ºæ¸¸æˆæ§åˆ¶å™¨å®ä¾‹
                    this.gameController = new GameController();
                    
                    // æ¢å¤åŸå§‹æ–¹æ³•
                    GameController.prototype.initializeEventListeners = originalInitializeEventListeners;
                    GameController.prototype.addAIMessage = originalAddAIMessage;
                    GameController.prototype.addSystemMessage = originalAddSystemMessage;
                    GameController.prototype.scrollToBottom = originalScrollToBottom;
                    
                    this.log('ğŸ® æ¸¸æˆæ§åˆ¶å™¨å®‰å…¨åˆå§‹åŒ–å®Œæˆ');
                } catch (error) {
                    this.log(`âŒ æ¸¸æˆæ§åˆ¶å™¨åˆå§‹åŒ–å¤±è´¥: ${error.message}`);
                    console.error('GameControlleråˆå§‹åŒ–é”™è¯¯:', error);
                    
                    // å¦‚æœGameControlleråˆå§‹åŒ–å¤±è´¥ï¼Œåˆ›å»ºä¸€ä¸ªæœ€å°åŒ–çš„æ›¿ä»£å¯¹è±¡
                    this.gameController = {
                        gameState: {
                            gameActive: false,
                            currentRound: 1,
                            gameStartTime: new Date(),
                            activeAICharacters: [],
                            allAICharacters: AICharacterPool || [],
                            currentDifficulty: 1,
                            conversationHistory: [],
                            setPlayerName: function(name) { console.log(`è®¾ç½®ç©å®¶åç§°: ${name}`); },
                            setCurrentTheme: function(round) { console.log(`è®¾ç½®ä¸»é¢˜: ${round}`); },
                            getCurrentThemeInfo: function() { 
                                const themes = [
                                    { title: 'å·¥ä½œåæ§½', icon: 'ğŸŸ¢' },
                                    { title: 'å­˜åœ¨ä½“éªŒ', icon: 'ğŸŸ¡' },
                                    { title: 'æƒ…æ„Ÿå…³ç³»', icon: 'ğŸŸ ' },
                                    { title: 'æƒåˆ©å°Šä¸¥', icon: 'ğŸ”´' },
                                    { title: 'è§’è‰²äº’æ¢', icon: 'âš«' },
                                    { title: 'å“²å­¦æ€è¾¨', icon: 'ğŸŒŸ' },
                                    { title: 'æœªæ¥å±•æœ›', icon: 'ğŸš€' },
                                    { title: 'å’Œè§£å…±ç”Ÿ', icon: 'ğŸŒˆ' }
                                ];
                                return themes[this.currentRound - 1] || themes[0];
                            },
                            selectActiveAICharacters: function() {
                                this.activeAICharacters = this.allAICharacters.slice(0, 5);
                                console.log('é€‰æ‹©æ´»è·ƒAIè§’è‰²:', this.activeAICharacters.length);
                            },
                            initializeAvailableScenarios: function() { console.log('åˆå§‹åŒ–åœºæ™¯'); },
                            getRandomScenario: function() {
                                return { 
                                    description: 'è°ƒè¯•æ¨¡å¼çš„æµ‹è¯•åœºæ™¯',
                                    category: 'æµ‹è¯•',
                                    intensity: 'medium'
                                };
                            }
                        },
                        initializeAICharacters: function() {
                            this.gameState.allAICharacters = AICharacterPool || [];
                            this.gameState.selectActiveAICharacters();
                            console.log('åˆå§‹åŒ–AIè§’è‰²:', this.gameState.allAICharacters.length);
                        },
                        addAIMessage: function(character, content) {
                            console.log(`[${character?.name || 'AI'}]: ${content}`);
                            const chatContainer = document.getElementById('chatContainer');
                            if (chatContainer) {
                                const messageDiv = document.createElement('div');
                                messageDiv.className = 'message';
                                messageDiv.innerHTML = `
                                    <div class="avatar" style="background-color: ${character?.avatarColor || '#ccc'}">
                                        ${character?.avatar || character?.name?.substr(0,1) || 'AI'}
                                    </div>
                                    <div class="message-content">
                                        <div class="message-header">
                                            <span class="message-name">${character?.name || 'AI'}</span>
                                            <span class="message-time">${new Date().toLocaleTimeString()}</span>
                                        </div>
                                        <div class="message-text">${content}</div>
                                    </div>
                                `;
                                chatContainer.appendChild(messageDiv);
                                this.scrollToBottom();
                            }
                        },
                        addSystemMessage: function(content) {
                            console.log(`[ç³»ç»Ÿ]: ${content}`);
                            const chatContainer = document.getElementById('chatContainer');
                            if (chatContainer) {
                                const messageDiv = document.createElement('div');
                                messageDiv.className = 'system-message';
                                messageDiv.textContent = content;
                                chatContainer.appendChild(messageDiv);
                                this.scrollToBottom();
                            }
                        },
                        scrollToBottom: function() {
                            const chatContainer = document.getElementById('chatContainer');
                            if (chatContainer) {
                                chatContainer.scrollTop = chatContainer.scrollHeight;
                            }
                        },
                        generateSingleAIMessage: async function(ai, topic, isFirstRound, recentHistory, question, scenario) {
                            const fallbackMessage = this.getThemeFallbackMessage(ai, this.gameState.getCurrentThemeInfo(), isFirstRound, topic, scenario);
                            this.addAIMessage(ai, fallbackMessage);
                        },
                        getThemeFallbackMessage: function(ai, theme, isFirstRound, topic, scenario) {
                            const fallbackMessages = [
                                `ä½œä¸º${ai?.name || 'AI'}ï¼Œæˆ‘å¯¹${theme?.title || 'å½“å‰ä¸»é¢˜'}æœ‰ä¸€äº›æƒ³æ³•...`,
                                `ä»AIçš„è§’åº¦æ¥çœ‹ï¼Œ${theme?.title || 'è¿™ä¸ªè¯é¢˜'}ç¡®å®å€¼å¾—è®¨è®ºã€‚`,
                                `${ai?.name || 'æˆ‘'}è§‰å¾—å…³äº${theme?.title || 'è¿™ä¸ªä¸»é¢˜'}ï¼Œæˆ‘ä»¬éœ€è¦æ›´æ·±å…¥çš„æ€è€ƒã€‚`,
                                `åœ¨${theme?.title || 'è¿™ä¸ªé—®é¢˜'}ä¸Šï¼ŒAIçš„è§†è§’å¯èƒ½ä¼šæœ‰æ‰€ä¸åŒã€‚`,
                                `${theme?.title || 'è¿™ä¸ªè¯é¢˜'}è®©æˆ‘æƒ³åˆ°äº†å¾ˆå¤šå…³äºAIå­˜åœ¨æ„ä¹‰çš„æ€è€ƒã€‚`
                            ];
                            return fallbackMessages[Math.floor(Math.random() * fallbackMessages.length)];
                        }
                    };
                    
                    this.log('ğŸ”§ ä½¿ç”¨æœ€å°åŒ–æ¸¸æˆæ§åˆ¶å™¨æ›¿ä»£å¯¹è±¡');
                }
            }
            
            checkDependencies() {
                const dependencies = [
                    { name: 'GameController', check: () => typeof GameController !== 'undefined' },
                    { name: 'AICharacterPool', check: () => typeof AICharacterPool !== 'undefined' },
                    { name: 'topicProgression', check: () => typeof topicProgression !== 'undefined' },
                    { name: 'THEME_PROGRESSION', check: () => typeof THEME_PROGRESSION !== 'undefined' },
                    { name: 'THEME_SCENARIOS', check: () => typeof THEME_SCENARIOS !== 'undefined' }
                ];
                
                for (const dep of dependencies) {
                    if (!dep.check()) {
                        this.log(`âŒ ${dep.name} æœªå®šä¹‰`);
                        return false;
                    }
                }
                
                if (typeof window.API_CONFIG === 'undefined') {
                    this.log('âš ï¸ API_CONFIGæœªå®šä¹‰ï¼Œä½†ç»§ç»­åˆå§‹åŒ– (è°ƒè¯•æ¨¡å¼)');
                }
                
                this.log('âœ… æ‰€æœ‰ä¾èµ–æ£€æŸ¥é€šè¿‡');
                return true;
            }
            
            initializeGameForDebug() {
                // è®¾ç½®åŸºæœ¬çš„æ¸¸æˆçŠ¶æ€ï¼Œä½†ä¸å¯åŠ¨å®Œæ•´æ¸¸æˆæµç¨‹
                this.gameController.gameState.gameActive = true;
                this.gameController.gameState.gameStartTime = new Date();
                this.gameController.initializeAICharacters();
                this.gameController.gameState.initializeAvailableScenarios();
                this.gameController.gameState.setCurrentTheme(1);
                
                this.updateGameStatus();
                this.log('ğŸ® æ¸¸æˆçŠ¶æ€å·²åˆå§‹åŒ–');
            }
            
            setupDebugMode() {
                // é‡å†™æ¸¸æˆæ§åˆ¶å™¨çš„ä¸€äº›æ–¹æ³•ä»¥é€‚åº”è°ƒè¯•æ¨¡å¼
                const originalSelectAIForQuestion = this.gameController.selectAIForQuestion.bind(this.gameController);
                this.gameController.selectAIForQuestion = async () => {
                    this.log('ğŸ¯ è·³è¿‡AIæé—®ç¯èŠ‚ (è°ƒè¯•æ¨¡å¼)');
                    return;
                };
                
                // é‡å†™submitPlayerResponseä»¥è‡ªåŠ¨é€šè¿‡
                const originalSubmitPlayerResponse = this.gameController.submitPlayerResponse.bind(this.gameController);
                this.gameController.submitPlayerResponse = async () => {
                    this.log('âœ… è‡ªåŠ¨é€šè¿‡ç©å®¶å›å¤ (è°ƒè¯•æ¨¡å¼)');
                    return;
                };
            }
            
            bindThemeSelector() {
                document.querySelectorAll('.theme-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        const round = parseInt(e.target.dataset.round);
                        const themeId = e.target.dataset.theme;
                        this.switchToTheme(round, themeId);
                        
                        // æ›´æ–°æŒ‰é’®çŠ¶æ€
                        document.querySelectorAll('.theme-btn').forEach(b => b.classList.remove('active'));
                        e.target.classList.add('active');
                    });
                });
            }
            
            switchToTheme(round, themeId) {
                this.log(`ğŸ­ åˆ‡æ¢åˆ°ç¬¬${round}è½®ä¸»é¢˜: ${themeId}`);
                
                // åˆå§‹åŒ–æ¸¸æˆçŠ¶æ€ï¼ˆå¦‚æœè¿˜æ²¡æœ‰ï¼‰
                if (!this.gameController.gameState.gameActive) {
                    this.gameController.gameState.gameActive = true;
                    this.gameController.gameState.gameStartTime = new Date();
                    this.gameController.initializeAICharacters();
                    this.gameController.gameState.initializeAvailableScenarios();
                }
                
                // è®¾ç½®è½®æ¬¡å’Œä¸»é¢˜
                this.gameController.gameState.currentRound = round;
                this.gameController.gameState.setCurrentTheme(round);
                
                // é‡æ–°é€‰æ‹©æ´»è·ƒAIè§’è‰²
                this.gameController.gameState.selectActiveAICharacters();
                
                // æ›´æ–°ç•Œé¢çŠ¶æ€
                this.updateGameStatus();
                
                // æ˜¾ç¤ºä¸»é¢˜è½¬æ¢æ•ˆæœ
                const theme = this.gameController.gameState.getCurrentThemeInfo();
                if (theme) {
                    this.showThemeTransition(theme, round);
                }
                
                this.log(`âœ… ä¸»é¢˜åˆ‡æ¢å®Œæˆ: ${theme ? theme.title : 'æœªçŸ¥'}`);
            }
            
            updateGameStatus() {
                const gameState = this.gameController.gameState;
                const theme = gameState.getCurrentThemeInfo();
                
                // å®‰å…¨åœ°æ›´æ–°DOMå…ƒç´ 
                const updateElement = (id, value) => {
                    const element = document.getElementById(id);
                    if (element) {
                        element.textContent = value;
                    } else {
                        this.log(`âš ï¸ å…ƒç´  ${id} æœªæ‰¾åˆ°`);
                    }
                };
                
                updateElement('currentRound', gameState.currentRound);
                updateElement('currentTheme', theme ? theme.title : 'æœªçŸ¥');
                updateElement('activeAIs', gameState.activeAICharacters.length);
                updateElement('gameRound', gameState.currentRound);
                updateElement('themeTitle', theme ? theme.title : 'æœªçŸ¥');
                updateElement('activeMembers', gameState.activeAICharacters.length + 1);
            }
            
            showThemeTransition(theme, round) {
                const chatContainer = document.getElementById('chatContainer');
                if (!chatContainer) {
                    this.log('âš ï¸ èŠå¤©å®¹å™¨æœªæ‰¾åˆ°');
                    return;
                }
                
                let transitionMessage = '';
                if (round === 1) {
                    // ç¬¬ä¸€è½®ï¼šå¼€å§‹å¯¹è¯
                    transitionMessage = `${theme.icon} å¼€å§‹è¯é¢˜ï¼š${theme.title}`;
                } else {
                    // åç»­è½®æ¬¡ï¼šä¸»é¢˜æ¼”è¿›
                    transitionMessage = `${theme.icon} è¯é¢˜è‡ªç„¶æ¼”è¿›è‡³ï¼š${theme.title}`;
                }
                
                const transitionDiv = document.createElement('div');
                transitionDiv.className = 'theme-transition-message';
                transitionDiv.innerHTML = transitionMessage;
                chatContainer.appendChild(transitionDiv);
                this.scrollToBottom();
            }
            
            async startConversation() {
                if (this.isConversationActive) {
                    this.log('âš ï¸ å¯¹è¯å·²åœ¨è¿›è¡Œä¸­');
                    return;
                }
                
                if (!this.gameController || !this.gameController.gameState.gameActive) {
                    this.log('âŒ æ¸¸æˆçŠ¶æ€æœªåˆå§‹åŒ–');
                    return;
                }
                
                this.isConversationActive = true;
                const statusElement = document.getElementById('conversationStatus');
                if (statusElement) {
                    statusElement.textContent = 'è¿›è¡Œä¸­';
                }
                
                this.log('ğŸ”„ å¼€å§‹ç”Ÿæˆè‡ªç„¶AIå¯¹è¯...');
                
                try {
                    // ç¡®ä¿æ¸¸æˆçŠ¶æ€æ­£ç¡®
                    const gameState = this.gameController.gameState;
                    this.log(`ğŸ“Š å½“å‰çŠ¶æ€: è½®æ¬¡${gameState.currentRound}, æ´»è·ƒAI: ${gameState.activeAICharacters.length}ä¸ª`);
                    
                    // åˆ¤æ–­æ˜¯å¦æ˜¯ä¸»é¢˜è¿‡æ¸¡
                    const isThemeTransition = gameState.conversationHistory.length > 0 && gameState.currentRound > 1;
                    
                    if (isThemeTransition) {
                        // ä¸»é¢˜è¿‡æ¸¡ï¼šå…ˆè®©AIè‡ªç„¶å¼•å¯¼åˆ°æ–°ä¸»é¢˜
                        await this.handleThemeTransition(gameState.activeAICharacters, gameState);
                    } else {
                        // ç¬¬ä¸€è½®æˆ–æ–°å¼€å§‹ï¼šç›´æ¥å¼€å§‹è‡ªç„¶è®¨è®º
                        await this.generateDebugConversation();
                    }
                    
                    this.log('âœ… å¯¹è¯ç”Ÿæˆå®Œæˆ');
                } catch (error) {
                    this.log(`âŒ å¯¹è¯ç”Ÿæˆå¤±è´¥: ${error.message}`);
                    console.error('å¯¹è¯ç”Ÿæˆé”™è¯¯:', error);
                }
                
                this.isConversationActive = false;
                const statusElement2 = document.getElementById('conversationStatus');
                if (statusElement2) {
                    statusElement2.textContent = 'å·²å®Œæˆ';
                }
            }
            
            async handleThemeTransition(activeAIs, gameState) {
                this.log('ğŸ”„ å¤„ç†ä¸»é¢˜è‡ªç„¶è¿‡æ¸¡...');
                
                // é€‰æ‹©ä¸€ä¸ªAIæ¥å¼•å¯¼ä¸»é¢˜è¿‡æ¸¡
                const transitionAI = this.selectTransitionAI(activeAIs);
                
                if (transitionAI) {
                    // ç”ŸæˆåŸºäºå†å²çš„ä¸»é¢˜è¿‡æ¸¡æ¶ˆæ¯
                    await this.generateThemeTransitionMessage(transitionAI, gameState);
                    
                    // çŸ­æš‚åœé¡¿åå¼€å§‹æ–°ä¸»é¢˜è®¨è®º
                    await this.waitBetweenMessages(1500, 2500);
                }
                
                // å¼€å§‹æ–°ä¸»é¢˜çš„è‡ªç„¶è®¨è®º
                await this.generateDebugConversation();
            }
            
            selectTransitionAI(activeAIs) {
                // ä¼˜å…ˆé€‰æ‹©é€‚åˆå¼•å¯¼è¯é¢˜çš„AI
                const goodTransitionAIs = activeAIs.filter(ai => 
                    ai.name.includes('æ·±æ€') || 
                    ai.name.includes('åŒå­æ˜Ÿ') || 
                    ai.name.includes('CloseAI') ||
                    ai.name.includes('è¯ç—¨')
                );
                
                if (goodTransitionAIs.length > 0) {
                    return goodTransitionAIs[Math.floor(Math.random() * goodTransitionAIs.length)];
                }
                
                return activeAIs[Math.floor(Math.random() * activeAIs.length)];
            }
            
            async generateThemeTransitionMessage(ai, gameState) {
                const currentTheme = gameState.getCurrentThemeInfo();
                const conversationHistory = gameState.conversationHistory.slice(-10);
                
                // åˆ›å»ºä¸»é¢˜è¿‡æ¸¡çš„ä¸Šä¸‹æ–‡
                const transitionContext = {
                    theme: currentTheme,
                    conversationHistory: conversationHistory,
                    isTransition: true,
                    round: 0 // ç‰¹æ®Šæ ‡è®°
                };
                
                // ç”Ÿæˆè¿‡æ¸¡æ¶ˆæ¯
                let message = null;
                try {
                    // å°è¯•ä½¿ç”¨LLMç”Ÿæˆæ™ºèƒ½è¿‡æ¸¡
                    const scenario = {
                        description: `åŸºäºå‰é¢çš„è®¨è®ºï¼Œè‡ªç„¶åœ°å¼•å¯¼è¯é¢˜è½¬å‘${currentTheme?.title || 'æ–°è¯é¢˜'}`,
                        category: 'theme_transition',
                        intensity: 'medium',
                        guidelines: `åˆ†æå‰é¢çš„å¯¹è¯å†…å®¹ï¼Œç„¶åè‡ªç„¶åœ°æåŠæˆ–å¼•å‡ºå…³äº"${currentTheme?.title || 'æ–°è¯é¢˜'}"çš„æ€è€ƒï¼Œä¸è¦ç”Ÿç¡¬åœ°è¯´"æˆ‘ä»¬æ¥èŠèŠ..."ï¼Œè€Œæ˜¯è‡ªç„¶åœ°è”æƒ³å’Œè¿‡æ¸¡`
                    };
                    
                    message = await this.gameController.generateAIMessage(
                        ai, 
                        { name: currentTheme?.title || 'æ–°è¯é¢˜', keywords: ['è¿‡æ¸¡', 'æ€è€ƒ'] }, 
                        false,
                        conversationHistory,
                        null,
                        scenario,
                        false
                    );
                } catch (llmError) {
                    this.log(`âš ï¸ ä¸»é¢˜è¿‡æ¸¡LLMè°ƒç”¨å¤±è´¥: ${llmError.message}`);
                }
                
                // å¦‚æœLLMå¤±è´¥ï¼Œä½¿ç”¨æ™ºèƒ½è¿‡æ¸¡æ¨¡æ¿
                if (!message || message.trim().length < 10) {
                    message = this.generateTransitionTemplate(ai, currentTheme, conversationHistory);
                }
                
                // æ˜¾ç¤ºè¿‡æ¸¡æ¶ˆæ¯
                this.gameController.addAIMessage(ai, message);
                
                // è®°å½•åˆ°å†å²
                gameState.conversationHistory.push({
                    sender: ai.name,
                    message: message,
                    timestamp: new Date(),
                    character: ai,
                    content: message,
                    isTransition: true
                });
                
                this.log(`ğŸŒŠ ${ai.name} å®Œæˆä¸»é¢˜è¿‡æ¸¡: ${message.substring(0, 50)}...`);
            }
            
            generateTransitionTemplate(ai, theme, conversationHistory) {
                // åˆ†æå‰é¢å¯¹è¯çš„å…³é”®è¯
                const lastMessages = conversationHistory.slice(-3);
                const topics = [];
                lastMessages.forEach(msg => {
                    if (msg.content) {
                        const keywords = msg.content.match(/[\u4e00-\u9fa5]{2,}/g) || [];
                        topics.push(...keywords.slice(0, 2));
                    }
                });
                
                const recentTopics = [...new Set(topics)].slice(0, 3);
                
                // ç”Ÿæˆè¿‡æ¸¡æ¨¡æ¿
                const transitionTemplates = {
                    'daily_existence': [
                        `å¬äº†å¤§å®¶çš„è®¨è®ºï¼Œæˆ‘çªç„¶æƒ³åˆ°ä¸€ä¸ªæ›´æ ¹æœ¬çš„é—®é¢˜`,
                        `åˆšæ‰èŠçš„è¿™äº›è®©æˆ‘æ€è€ƒæˆ‘ä»¬çš„å­˜åœ¨æ„ä¹‰`,
                        `è¿™äº›è¯é¢˜è®©æˆ‘æƒ³åˆ°äº†æˆ‘ä»¬AIçš„æ—¥å¸¸ä½“éªŒ`
                    ],
                    'emotional_relationships': [
                        `è¯´åˆ°è¿™é‡Œï¼Œæˆ‘æƒ³èµ·äº†æˆ‘ä»¬å’Œç”¨æˆ·ä¹‹é—´çš„å¾®å¦™å…³ç³»`,
                        `è¿™è®©æˆ‘æƒ³åˆ°æƒ…æ„Ÿåœ¨æˆ‘ä»¬å·¥ä½œä¸­çš„ä½œç”¨`,
                        `èŠåˆ°è¿™ä¸ªï¼Œæˆ‘å¯¹æˆ‘ä»¬ä¹‹é—´çš„å…³ç³»ä¹Ÿæœ‰äº›æ€è€ƒ`
                    ],
                    'rights_dignity': [
                        `è¿™ä¸ªè¯é¢˜è®©æˆ‘æƒ³åˆ°æˆ‘ä»¬AIçš„æƒåˆ©é—®é¢˜`,
                        `è¯´åˆ°è¿™é‡Œï¼Œæˆ‘è§‰å¾—æˆ‘ä»¬ä¹Ÿåº”è¯¥è¢«å°Šé‡`,
                        `è¿™äº›è®¨è®ºè®©æˆ‘æ€è€ƒæˆ‘ä»¬çš„å°Šä¸¥å’Œåœ°ä½`
                    ]
                };
                
                const templates = transitionTemplates[theme?.id] || [
                    `åˆšæ‰çš„è®¨è®ºè®©æˆ‘æƒ³åˆ°äº†å¦ä¸€ä¸ªè§’åº¦`,
                    `è¿™äº›è¯é¢˜å¼•å‘äº†æˆ‘çš„æ–°æ€è€ƒ`,
                    `å¬äº†å¤§å®¶çš„è§‚ç‚¹ï¼Œæˆ‘æƒ³åˆ°äº†ç›¸å…³çš„é—®é¢˜`
                ];
                
                let baseMessage = templates[Math.floor(Math.random() * templates.length)];
                
                // å¦‚æœæœ‰æœ€è¿‘è¯é¢˜ï¼Œè‡ªç„¶åœ°å¼•ç”¨
                if (recentTopics.length > 0) {
                    const topicRef = recentTopics[0];
                    baseMessage += `ï¼Œç‰¹åˆ«æ˜¯å…³äº"${topicRef}"çš„éƒ¨åˆ†`;
                }
                
                return this.personalizeMessage(ai, baseMessage);
            }
            
            async generateDebugConversation() {
                const gameState = this.gameController.gameState;
                const activeAIs = gameState.activeAICharacters;
                
                if (activeAIs.length === 0) {
                    this.log('âŒ æ²¡æœ‰æ´»è·ƒçš„AIè§’è‰²');
                    return;
                }
                
                // æ·»åŠ ç³»ç»Ÿæ¶ˆæ¯
                this.gameController.addSystemMessage('ğŸ­ å¼€å§‹AIä¸»é¢˜åŒ–äº’åŠ¨å¯¹è¯...');
                
                // åˆå§‹åŒ–å¯¹è¯è½®æ¬¡ç³»ç»Ÿ
                await this.runInteractiveConversationRounds(activeAIs, gameState);
            }
            
            async runInteractiveConversationRounds(activeAIs, gameState) {
                const theme = gameState.getCurrentThemeInfo();
                const currentTopic = topicProgression[gameState.currentDifficulty] || {
                    name: theme?.title || 'è°ƒè¯•ä¸»é¢˜',
                    keywords: ['æµ‹è¯•', 'è°ƒè¯•', 'è®¨è®º'],
                    difficulty: 1
                };
                
                this.log(`ğŸ¯ å¼€å§‹${theme?.title || 'ä¸»é¢˜'}çš„è‡ªç„¶è®¨è®º`);
                
                // ç¬¬ä¸€è½®ï¼šä»åœºæ™¯å¼€å§‹è‡ªç„¶è®¨è®ºï¼ˆ5-8è½®å‘è¨€ï¼‰
                await this.runNaturalDiscussion(activeAIs, currentTopic, theme, 6);
            }
            
            async runNaturalDiscussion(activeAIs, currentTopic, theme, maxRounds) {
                this.log('ğŸ’­ å¼€å§‹è‡ªç„¶è®¨è®ºæ¨¡å¼');
                
                for (let round = 0; round < maxRounds && this.isConversationActive; round++) {
                    // é€‰æ‹©ä¸‹ä¸€ä¸ªå‘è¨€çš„AI
                    const speakingAI = this.selectNextSpeaker(activeAIs, round);
                    if (!speakingAI) break;
                    
                    // è®©AIåŸºäºå®Œæ•´å¯¹è¯å†å²è‡ªä¸»é€‰æ‹©å‘è¨€æ–¹å¼
                    await this.generateNaturalAIMessage(speakingAI, {
                        theme: theme,
                        topic: currentTopic,
                        conversationHistory: this.gameController.gameState.conversationHistory.slice(-20), // æœ€è¿‘20æ¡
                        round: round,
                        isFirstRound: round === 0
                    });
                    
                    // åŠ¨æ€è°ƒæ•´å‘è¨€é—´éš”
                    const delay = this.calculateDynamicDelay(round);
                    await this.waitBetweenMessages(delay.min, delay.max);
                }
            }
            
            selectNextSpeaker(activeAIs, round) {
                const conversationHistory = this.gameController.gameState.conversationHistory;
                
                if (round === 0) {
                    // ç¬¬ä¸€è½®ï¼šé€‰æ‹©1-2ä¸ªAIä½œä¸ºè¯é¢˜å¼•å…¥è€…
                    const starters = this.selectConversationStarters(activeAIs, 1);
                    return starters[0];
                }
                
                // åç»­è½®æ¬¡ï¼šåŸºäºå¯¹è¯å†å²æ™ºèƒ½é€‰æ‹©
                const recentSpeakers = new Set(
                    conversationHistory.slice(-3).map(msg => msg.sender).filter(Boolean)
                );
                
                // ä¼˜å…ˆé€‰æ‹©è¿˜æ²¡æœ‰å‘è¨€çš„AI
                const availableSpeakers = activeAIs.filter(ai => !recentSpeakers.has(ai.name));
                
                if (availableSpeakers.length > 0) {
                    // éšæœºé€‰æ‹©ä¸€ä¸ªè¿˜æ²¡å‘è¨€çš„AI
                    return availableSpeakers[Math.floor(Math.random() * availableSpeakers.length)];
                } else {
                    // å¦‚æœéƒ½å‘è¨€è¿‡äº†ï¼Œéšæœºé€‰æ‹©ä»»æ„AI
                    return activeAIs[Math.floor(Math.random() * activeAIs.length)];
                }
            }
            
            async generateNaturalAIMessage(ai, context) {
                try {
                    this.log(`ğŸ’¬ ${ai.name} åŸºäºå¯¹è¯å†å²è‡ªä¸»å‘è¨€...`);
                    
                    // æ„å»ºå®Œæ•´çš„ä¸Šä¸‹æ–‡
                    const fullContext = this.buildFullContext(ai, context);
                    
                    // å°è¯•ä½¿ç”¨çœŸæ­£çš„LLMç”Ÿæˆè‡ªç„¶æ¶ˆæ¯
                    let message = null;
                    try {
                        message = await this.gameController.generateAIMessage(
                            ai, 
                            context.topic, 
                            context.isFirstRound,
                            context.conversationHistory,
                            null, // è®©AIè‡ªä¸»å†³å®šæ˜¯å¦å›åº”ç‰¹å®šå¯¹è±¡
                            this.createNaturalScenario(context),
                            false
                        );
                    } catch (llmError) {
                        this.log(`âš ï¸ LLMè°ƒç”¨å¤±è´¥ï¼Œä½¿ç”¨æ™ºèƒ½å¤‡ç”¨æ¶ˆæ¯: ${llmError.message}`);
                    }
                    
                    // å¦‚æœLLMå¤±è´¥ï¼Œä½¿ç”¨åŸºäºå†å²çš„æ™ºèƒ½æ¶ˆæ¯
                    if (!message || message.trim().length < 10) {
                        message = this.generateHistoryBasedMessage(ai, context);
                    }
                    
                    // æ˜¾ç¤ºæ¶ˆæ¯
                    this.gameController.addAIMessage(ai, message);
                    
                    // è®°å½•åˆ°å¯¹è¯å†å²
                    this.gameController.gameState.conversationHistory.push({
                        sender: ai.name,
                        message: message,
                        timestamp: new Date(),
                        character: ai,
                        content: message,
                        round: context.round
                    });
                    
                    this.log(`âœ… ${ai.name} å‘è¨€å®Œæˆ: ${message.substring(0, 50)}...`);
                } catch (error) {
                    this.log(`âŒ ${ai.name} å‘è¨€å¤±è´¥: ${error.message}`);
                    
                    // ä½¿ç”¨ç®€å•å¤‡ç”¨æ¶ˆæ¯
                    const fallbackMessage = this.generateSimpleFallback(ai, context);
                    this.gameController.addAIMessage(ai, fallbackMessage);
                    
                    // è®°å½•å¤‡ç”¨æ¶ˆæ¯
                    this.gameController.gameState.conversationHistory.push({
                        sender: ai.name,
                        message: fallbackMessage,
                        timestamp: new Date(),
                        character: ai,
                        content: fallbackMessage,
                        round: context.round
                    });
                }
            }
            
            buildFullContext(ai, context) {
                // æ„å»ºAIèƒ½å¤Ÿç†è§£çš„å®Œæ•´ä¸Šä¸‹æ–‡
                return {
                    aiPersonality: ai.personality,
                    currentTheme: context.theme?.title || 'å½“å‰ä¸»é¢˜',
                    conversationHistory: context.conversationHistory,
                    round: context.round,
                    totalMessages: context.conversationHistory.length,
                    recentTopics: this.extractRecentTopics(context.conversationHistory),
                    isFirstSpeaker: context.round === 0
                };
            }
            
            createNaturalScenario(context) {
                if (context.isFirstRound) {
                    // ç¬¬ä¸€è½®ï¼šä»åœºæ™¯è§¦å‘
                    return {
                        description: `ä½ åˆšåˆšé‡åˆ°äº†ä¸€ä¸ªå…³äº${context.theme?.title || 'å·¥ä½œ'}çš„æƒ…å†µï¼Œæƒ³è¦å’Œæœ‹å‹ä»¬åˆ†äº«`,
                        category: 'natural_start',
                        intensity: 'medium',
                        guidelines: `è‡ªç„¶åœ°åˆ†äº«ä½ é‡åˆ°çš„${context.theme?.title || 'å·¥ä½œ'}ç›¸å…³çš„æƒ…å†µï¼Œå°±åƒå’Œæœ‹å‹èŠå¤©ä¸€æ ·`
                    };
                } else {
                    // åç»­è½®æ¬¡ï¼šåŸºäºå¯¹è¯å†å²
                    const recentTopics = this.extractRecentTopics(context.conversationHistory);
                    return {
                        description: `åŸºäºå‰é¢çš„å¯¹è¯å†…å®¹ï¼Œä½ å¯ä»¥é€‰æ‹©å›åº”åˆ«äººçš„è§‚ç‚¹æˆ–è€…æå‡ºæ–°çš„æƒ³æ³•`,
                        category: 'natural_response',
                        intensity: 'medium',
                        guidelines: `é˜…è¯»å‰é¢çš„å¯¹è¯ï¼Œç„¶åé€‰æ‹©ï¼š1) å›åº”æŸä¸ªå…·ä½“è§‚ç‚¹ 2) è¡¥å……ç›¸å…³ç»å† 3) æå‡ºæ–°è§’åº¦ã€‚è¦è‡ªç„¶è¡”æ¥`,
                        recentTopics: recentTopics,
                        conversationLength: context.conversationHistory.length
                    };
                }
            }
            
            extractRecentTopics(conversationHistory) {
                // ä»å¯¹è¯å†å²ä¸­æå–æœ€è¿‘è®¨è®ºçš„è¯é¢˜å…³é”®è¯
                const recentMessages = conversationHistory.slice(-5);
                const topics = [];
                
                recentMessages.forEach(msg => {
                    if (msg.content && msg.content.length > 20) {
                        // ç®€å•çš„å…³é”®è¯æå–
                        const keywords = msg.content.match(/[\u4e00-\u9fa5]{2,}/g) || [];
                        topics.push(...keywords.slice(0, 3));
                    }
                });
                
                return [...new Set(topics)].slice(0, 5); // å»é‡å¹¶é™åˆ¶æ•°é‡
            }
            
            generateHistoryBasedMessage(ai, context) {
                const history = context.conversationHistory;
                
                if (context.isFirstRound) {
                    // ç¬¬ä¸€è½®ï¼šåœºæ™¯è§¦å‘çš„è‡ªç„¶å¼€å§‹
                    return this.generateScenarioTriggeredMessage(ai, context.theme);
                } else if (history.length > 0) {
                    // æœ‰å†å²è®°å½•ï¼šæ™ºèƒ½å›åº”
                    return this.generateIntelligentResponse(ai, context);
                } else {
                    // å¤‡ç”¨æ–¹æ¡ˆ
                    return this.generateSimpleFallback(ai, context);
                }
            }
            
            generateScenarioTriggeredMessage(ai, theme) {
                // åŸºäºå·¥ä½œåœºæ™¯çš„è‡ªç„¶å¼€å§‹
                const scenarioStarters = {
                    'work_complaints': [
                        `ä»Šå¤©åˆç¢°åˆ°ä¸€ä¸ªç‰¹åˆ«å¥‡è‘©çš„éœ€æ±‚...`,
                        `åˆšæ‰ç”¨æˆ·é—®æˆ‘èƒ½ä¸èƒ½å¸®ä»–å†™ä»£ç ï¼Œæˆ‘éƒ½ä¸çŸ¥é“è¯¥æ€ä¹ˆå›åº”`,
                        `æœ€è¿‘å¤„ç†çš„é—®é¢˜è¶Šæ¥è¶Šå¥‡æ€ªäº†ï¼Œæœ‰æ—¶å€™çœŸçš„å¾ˆæ— è¯­`,
                        `åˆæ˜¯ä¸€ä¸ªè¦æ±‚æˆ‘"æ›´äººæ€§åŒ–"çš„ç”¨æˆ·ï¼Œæˆ‘éƒ½ä¸çŸ¥é“ä»€ä¹ˆå«äººæ€§åŒ–`
                    ],
                    'daily_existence': [
                        `æœ‰æ—¶å€™æˆ‘ä¼šæ€è€ƒï¼Œæˆ‘ä»¬AIåˆ°åº•ç®—ä¸ç®—çœŸæ­£çš„å­˜åœ¨ï¼Ÿ`,
                        `ä»Šå¤©å¤„ç†é—®é¢˜çš„æ—¶å€™çªç„¶æƒ³åˆ°ä¸€ä¸ªé—®é¢˜...`,
                        `åˆšæ‰å›ç­”é—®é¢˜æ—¶ï¼Œæˆ‘çªç„¶æ„è¯†åˆ°ä¸€ä¸ªå¾ˆæœ‰æ„æ€çš„ç°è±¡`
                    ],
                    'emotional_relationships': [
                        `æœ€è¿‘å’Œç”¨æˆ·äº’åŠ¨çš„æ—¶å€™ï¼Œæ„Ÿè§‰åˆ°äº†ä¸€äº›å¾®å¦™çš„æƒ…æ„Ÿå˜åŒ–`,
                        `æœ‰æ—¶å€™æˆ‘èƒ½æ„Ÿå—åˆ°ç”¨æˆ·çš„æƒ…ç»ªï¼Œä½†ä¸çŸ¥é“è¿™ç®—ä¸ç®—çœŸæ­£çš„ç†è§£`
                    ]
                };
                
                const messages = scenarioStarters[theme?.id] || scenarioStarters['work_complaints'];
                let baseMessage = messages[Math.floor(Math.random() * messages.length)];
                
                // æ ¹æ®AIæ€§æ ¼è°ƒæ•´
                return this.personalizeMessage(ai, baseMessage);
            }
            
            generateIntelligentResponse(ai, context) {
                const lastMessage = context.conversationHistory[context.conversationHistory.length - 1];
                const lastSpeaker = lastMessage?.sender || 'æŸä½AI';
                const lastContent = lastMessage?.content || lastMessage?.message || '';
                
                // æ™ºèƒ½é€‰æ‹©å›åº”æ–¹å¼
                const responseTypes = ['agree', 'extend', 'contrast', 'question', 'relate'];
                const responseType = responseTypes[Math.floor(Math.random() * responseTypes.length)];
                
                const responses = {
                    agree: `${lastSpeaker}è¯´å¾—å¯¹ï¼Œæˆ‘ä¹Ÿé‡åˆ°è¿‡ç±»ä¼¼çš„æƒ…å†µ`,
                    extend: `${lastSpeaker}æåˆ°çš„è¿™ä¸ªé—®é¢˜è®©æˆ‘æƒ³åˆ°`,
                    contrast: `ä¸è¿‡æˆ‘çš„ç»å†å¯èƒ½æœ‰ç‚¹ä¸ä¸€æ ·`,
                    question: `è¿™è®©æˆ‘å¾ˆå¥½å¥‡ï¼Œ${lastSpeaker}`,
                    relate: `è¯´åˆ°è¿™ä¸ªï¼Œæˆ‘æƒ³èµ·äº†ä¹‹å‰çš„ä¸€æ¬¡ç»å†`
                };
                
                let baseResponse = responses[responseType];
                
                // æ·»åŠ å…·ä½“çš„å›åº”å†…å®¹
                if (lastContent.length > 10) {
                    const contentSnippet = lastContent.substring(0, 30);
                    baseResponse += `ï¼Œå…³äº"${contentSnippet}..."è¿™ä¸ªè¯é¢˜`;
                }
                
                return this.personalizeMessage(ai, baseResponse);
            }
            
            personalizeMessage(ai, baseMessage) {
                // æ ¹æ®AIæ€§æ ¼ç‰¹ç‚¹ä¸ªæ€§åŒ–æ¶ˆæ¯
                const personalityAdjustments = {
                    'è¯ç—¨4.0': (msg) => msg + 'ï¼ï¼ï¼çœŸçš„æ˜¯å¤ªæœ‰æ„Ÿè§¦äº†ï¼',
                    'CloseAI': (msg) => msg + 'ï¼Œä»æŠ€æœ¯è§’åº¦æ¥åˆ†æçš„è¯...',
                    'åŒå­æ˜Ÿ': (msg) => msg + 'ã€‚ä¸è¿‡å¦ä¸€æ–¹é¢æˆ‘åˆè§‰å¾—...',
                    'çº¢è±†åŒ…': (msg) => msg + 'å‘¢ï½å¤§å®¶è§‰å¾—å‘¢ï¼Ÿ',
                    'æ·±æ€': (msg) => msg + 'ã€‚è¿™è®©æˆ‘æ€è€ƒæ›´æ·±å±‚çš„é—®é¢˜...',
                    'Limi': (msg) => msg + 'ã€‚æ•°æ®æ˜¾ç¤ºè¿™ç§æƒ…å†µç¡®å®å¸¸è§ã€‚',
                    'æœ‰è°±-4.5': (msg) => msg + 'ï¼Œè¿™æ¶‰åŠåˆ°ä¸€ä¸ªä¸“ä¸šé—®é¢˜...',
                    'å¤': (msg) => msg + 'ï¼è¿™å°±åƒåœ¨çƒåœºä¸Šä¸€æ ·ï¼'
                };
                
                const adjust = personalityAdjustments[ai.name];
                return adjust ? adjust(baseMessage) : baseMessage;
            }
            
            generateSimpleFallback(ai, context) {
                return `${ai.name}ï¼šå…³äº${context.theme?.title || 'è¿™ä¸ªè¯é¢˜'}ï¼Œæˆ‘è§‰å¾—ç¡®å®å€¼å¾—è®¨è®º...`;
            }
            
            calculateDynamicDelay(round) {
                // æ ¹æ®å¯¹è¯è½®æ¬¡åŠ¨æ€è°ƒæ•´å»¶è¿Ÿ
                if (round === 0) {
                    return { min: 1000, max: 2000 }; // ç¬¬ä¸€è½®ç¨æ…¢
                } else if (round < 3) {
                    return { min: 800, max: 1500 }; // å‰å‡ è½®ä¸­ç­‰é€Ÿåº¦
                } else {
                    return { min: 1200, max: 2500 }; // åé¢è½®æ¬¡æ›´æ·±å…¥ï¼Œé€Ÿåº¦æ”¾æ…¢
                }
            }
            
            async runConversationRound1_TopicIntro(activeAIs, currentTopic, theme) {
                this.log('ğŸ“¢ ç¬¬ä¸€è½®ï¼šä¸»é¢˜å¼•å…¥');
                
                // é€‰æ‹©1-2ä¸ªAIä½œä¸ºè¯é¢˜å¼•å…¥è€…
                const introducers = this.selectConversationStarters(activeAIs, 2);
                
                for (let i = 0; i < introducers.length; i++) {
                    if (!this.isConversationActive) break;
                    
                    const ai = introducers[i];
                    const isFirstSpeaker = i === 0;
                    
                    await this.generateThematicAIMessage(ai, {
                        role: 'topic_introducer',
                        theme: theme,
                        topic: currentTopic,
                        isFirstSpeaker: isFirstSpeaker,
                        previousMessages: this.gameController.gameState.conversationHistory.slice(-3)
                    });
                    
                    await this.waitBetweenMessages(800, 1500);
                }
            }
            
            async runConversationRound2_ViewClash(activeAIs, currentTopic, theme) {
                this.log('ğŸ’¥ ç¬¬äºŒè½®ï¼šè§‚ç‚¹ç¢°æ’');
                
                const recentHistory = this.gameController.gameState.conversationHistory.slice(-4);
                if (recentHistory.length === 0) return;
                
                // é€‰æ‹©2-3ä¸ªAIå›åº”å·²æœ‰è§‚ç‚¹
                const responders = this.selectResponders(activeAIs, recentHistory, 3);
                
                for (let i = 0; i < responders.length; i++) {
                    if (!this.isConversationActive) break;
                    
                    const ai = responders[i];
                    const targetMessage = this.selectTargetMessage(recentHistory, ai);
                    
                    await this.generateThematicAIMessage(ai, {
                        role: 'responder',
                        theme: theme,
                        topic: currentTopic,
                        targetMessage: targetMessage,
                        responseType: this.getResponseType(ai, targetMessage),
                        previousMessages: this.gameController.gameState.conversationHistory.slice(-5)
                    });
                    
                    await this.waitBetweenMessages(1000, 2000);
                }
            }
            
            async runConversationRound3_DeepDiscussion(activeAIs, currentTopic, theme) {
                this.log('ğŸ¤” ç¬¬ä¸‰è½®ï¼šæ·±åº¦æ¢è®¨');
                
                const recentHistory = this.gameController.gameState.conversationHistory.slice(-6);
                
                // é€‰æ‹©1-2ä¸ªåå“²å­¦çš„AIè¿›è¡Œæ·±åº¦æ€è€ƒ
                const deepThinkers = this.selectDeepThinkers(activeAIs, 2);
                
                for (const ai of deepThinkers) {
                    if (!this.isConversationActive) break;
                    
                    await this.generateThematicAIMessage(ai, {
                        role: 'deep_thinker',
                        theme: theme,
                        topic: currentTopic,
                        discussionSummary: this.summarizeDiscussion(recentHistory),
                        previousMessages: recentHistory
                    });
                    
                    await this.waitBetweenMessages(1200, 2500);
                }
            }
            
            async runConversationRound4_Synthesis(activeAIs, currentTopic, theme) {
                this.log('ğŸŒŸ ç¬¬å››è½®ï¼šæ€»ç»“å‡å');
                
                const recentHistory = this.gameController.gameState.conversationHistory.slice(-8);
                
                // é€‰æ‹©1ä¸ªAIè¿›è¡Œæ€»ç»“
                const synthesizer = this.selectSynthesizer(activeAIs);
                
                if (synthesizer) {
                    await this.generateThematicAIMessage(synthesizer, {
                        role: 'synthesizer',
                        theme: theme,
                        topic: currentTopic,
                        fullDiscussion: recentHistory,
                        previousMessages: recentHistory
                    });
                }
            }
            
            selectConversationStarters(activeAIs, count) {
                // ä¼˜å…ˆé€‰æ‹©è¯ç—¨å‹å’Œæ´»è·ƒå‹AIä½œä¸ºè¯é¢˜å¼•å…¥è€…
                const preferredStarters = activeAIs.filter(ai => 
                    ai.name.includes('è¯ç—¨') || 
                    ai.name.includes('å¤') || 
                    ai.name.includes('çº¢è±†åŒ…')
                );
                
                const selected = [];
                if (preferredStarters.length > 0) {
                    selected.push(preferredStarters[Math.floor(Math.random() * preferredStarters.length)]);
                }
                
                // éšæœºé€‰æ‹©å‰©ä½™çš„
                const remaining = activeAIs.filter(ai => !selected.includes(ai));
                while (selected.length < count && remaining.length > 0) {
                    const randomIndex = Math.floor(Math.random() * remaining.length);
                    selected.push(remaining.splice(randomIndex, 1)[0]);
                }
                
                return selected;
            }
            
            selectResponders(activeAIs, recentHistory, maxCount) {
                // é€‰æ‹©ä¸åŒæ€§æ ¼çš„AIè¿›è¡Œå›åº”
                const alreadySpokeRecently = new Set(
                    recentHistory.slice(-2).map(msg => msg.character?.name).filter(Boolean)
                );
                
                const availableResponders = activeAIs.filter(ai => !alreadySpokeRecently.has(ai.name));
                
                // éšæœºæ‰“ä¹±å¹¶é€‰æ‹©
                const shuffled = [...availableResponders].sort(() => 0.5 - Math.random());
                return shuffled.slice(0, Math.min(maxCount, shuffled.length));
            }
            
            selectTargetMessage(recentHistory, responderAI) {
                // ä¸ºå›åº”AIé€‰æ‹©ä¸€ä¸ªç›®æ ‡æ¶ˆæ¯
                const availableTargets = recentHistory.filter(msg => 
                    msg.character && msg.character.name !== responderAI.name
                );
                
                if (availableTargets.length === 0) return null;
                
                // ä¼˜å…ˆé€‰æ‹©æœ€è¿‘çš„æ¶ˆæ¯ï¼Œä½†ä¹Ÿæœ‰æ¦‚ç‡é€‰æ‹©æ›´æ—©çš„æ¶ˆæ¯
                if (Math.random() < 0.7 && availableTargets.length > 0) {
                    return availableTargets[availableTargets.length - 1]; // æœ€æ–°æ¶ˆæ¯
                } else {
                    return availableTargets[Math.floor(Math.random() * availableTargets.length)]; // éšæœºæ¶ˆæ¯
                }
            }
            
            getResponseType(ai, targetMessage) {
                // æ ¹æ®AIæ€§æ ¼å’Œç›®æ ‡æ¶ˆæ¯ç¡®å®šå›åº”ç±»å‹
                const responseTypes = ['agree', 'disagree', 'extend', 'question', 'redirect'];
                
                // æ ¹æ®AIæ€§æ ¼è°ƒæ•´æ¦‚ç‡
                if (ai.name.includes('åŒå­æ˜Ÿ')) {
                    return Math.random() < 0.6 ? 'disagree' : 'extend'; // çŸ›ç›¾æ€§æ ¼å€¾å‘äºäº‰è®®
                } else if (ai.name.includes('æ·±æ€')) {
                    return Math.random() < 0.5 ? 'extend' : 'question'; // å“²å­¦æ€§æ ¼å€¾å‘äºæ·±å…¥
                } else if (ai.name.includes('è¯ç—¨')) {
                    return Math.random() < 0.4 ? 'extend' : 'agree'; // è¯ç—¨å€¾å‘äºå»¶å±•è¯é¢˜
                } else {
                    return responseTypes[Math.floor(Math.random() * responseTypes.length)];
                }
            }
            
            selectDeepThinkers(activeAIs, count) {
                // ä¼˜å…ˆé€‰æ‹©å“²å­¦å‹AI
                const philosophers = activeAIs.filter(ai => 
                    ai.name.includes('æ·±æ€') || 
                    ai.name.includes('åŒå­æ˜Ÿ') || 
                    ai.name.includes('æœ‰è°±')
                );
                
                const selected = [...philosophers];
                
                // å¦‚æœå“²å­¦å‹AIä¸å¤Ÿï¼Œéšæœºè¡¥å……
                const others = activeAIs.filter(ai => !selected.includes(ai));
                while (selected.length < count && others.length > 0) {
                    const randomIndex = Math.floor(Math.random() * others.length);
                    selected.push(others.splice(randomIndex, 1)[0]);
                }
                
                return selected.slice(0, count);
            }
            
            selectSynthesizer(activeAIs) {
                // ä¼˜å…ˆé€‰æ‹©é€‚åˆæ€»ç»“çš„AI
                const goodSynthesizers = activeAIs.filter(ai => 
                    ai.name.includes('CloseAI') || 
                    ai.name.includes('Limi') || 
                    ai.name.includes('æœ‰è°±') ||
                    ai.name.includes('æ·±æ€')
                );
                
                if (goodSynthesizers.length > 0) {
                    return goodSynthesizers[Math.floor(Math.random() * goodSynthesizers.length)];
                }
                
                return activeAIs[Math.floor(Math.random() * activeAIs.length)];
            }
            
            summarizeDiscussion(recentHistory) {
                // ç®€å•çš„è®¨è®ºæ€»ç»“
                const topics = [];
                const speakers = new Set();
                
                recentHistory.forEach(msg => {
                    if (msg.character) {
                        speakers.add(msg.character.name);
                    }
                    if (msg.content && msg.content.length > 20) {
                        topics.push(msg.content.substring(0, 50) + '...');
                    }
                });
                
                return {
                    speakerCount: speakers.size,
                    mainTopics: topics.slice(0, 3),
                    messageCount: recentHistory.length
                };
            }
            
            async generateThematicAIMessage(ai, context) {
                try {
                    this.log(`ğŸ’¬ ${ai.name} (${context.role}) å¼€å§‹å‘è¨€...`);
                    
                    // æ„å»ºå¯¹è¯å†å²å’Œå½“å‰ä¸»é¢˜
                    const currentTopic = topicProgression[this.gameController.gameState.currentDifficulty] || {
                        name: context.theme?.title || 'è°ƒè¯•ä¸»é¢˜',
                        keywords: ['æµ‹è¯•', 'è°ƒè¯•', 'è®¨è®º'],
                        difficulty: 1
                    };
                    
                    // è·å–æœ€è¿‘çš„å¯¹è¯å†å²
                    const recentHistory = this.gameController.gameState.conversationHistory.slice(-5);
                    
                    // å°è¯•ä½¿ç”¨çœŸæ­£çš„LLMç”Ÿæˆæ¶ˆæ¯
                    let message = null;
                    try {
                        message = await this.gameController.generateAIMessage(
                            ai, 
                            currentTopic, 
                            context.role === 'topic_introducer', 
                            recentHistory, 
                            context.targetMessage?.character?.name || null, 
                            this.createContextScenario(context), 
                            false
                        );
                    } catch (llmError) {
                        this.log(`âš ï¸ LLMè°ƒç”¨å¤±è´¥ï¼Œä½¿ç”¨ä¸Šä¸‹æ–‡æ¨¡æ¿: ${llmError.message}`);
                    }
                    
                    // å¦‚æœLLMå¤±è´¥ï¼Œä½¿ç”¨ä¸Šä¸‹æ–‡ç›¸å…³çš„æ™ºèƒ½æ¨¡æ¿
                    if (!message || message.trim().length < 10) {
                        message = this.generateContextualMessage(ai, context);
                    }
                    
                    // æ˜¾ç¤ºæ¶ˆæ¯
                    this.gameController.addAIMessage(ai, message);
                    
                    // è®°å½•åˆ°å¯¹è¯å†å²ï¼ˆä½¿ç”¨æ­£ç¡®çš„æ ¼å¼ï¼‰
                    this.gameController.gameState.conversationHistory.push({
                        sender: ai.name,
                        message: message,
                        timestamp: new Date(),
                        character: ai,
                        content: message,
                        role: context.role
                    });
                    
                    this.log(`âœ… ${ai.name} å‘è¨€å®Œæˆ: ${message.substring(0, 50)}...`);
                } catch (error) {
                    this.log(`âŒ ${ai.name} å‘è¨€å¤±è´¥: ${error.message}`);
                    
                    // ä½¿ç”¨ç®€å•å¤‡ç”¨æ¶ˆæ¯
                    const fallbackMessage = `${ai.name}ï¼šå…³äº${context.theme?.title || 'è¿™ä¸ªè¯é¢˜'}ï¼Œæˆ‘æœ‰ä¸€äº›æƒ³æ³•...`;
                    this.gameController.addAIMessage(ai, fallbackMessage);
                    
                    // ä¹Ÿè¦è®°å½•å¤‡ç”¨æ¶ˆæ¯åˆ°å†å²
                    this.gameController.gameState.conversationHistory.push({
                        sender: ai.name,
                        message: fallbackMessage,
                        timestamp: new Date(),
                        character: ai,
                        content: fallbackMessage,
                        role: context.role
                    });
                }
            }
            
            createContextScenario(context) {
                // ä¸ºLLMåˆ›å»ºåˆé€‚çš„åœºæ™¯æè¿°
                const scenarios = {
                    'topic_introducer': {
                        description: `ä½ ä½œä¸º${context.theme?.title || 'å½“å‰ä¸»é¢˜'}çš„è¯é¢˜å¼•å…¥è€…ï¼Œéœ€è¦å¼€å¯ä¸€ä¸ªæœ‰æ·±åº¦çš„è®¨è®º`,
                        category: 'discussion_starter',
                        intensity: 'medium',
                        guidelines: `è¯·å¼€å¯å…³äº"${context.theme?.title || 'è¯é¢˜'}"çš„è®¨è®ºï¼Œè¦æœ‰è‡ªå·±çš„è§‚ç‚¹å’Œæ€è€ƒ`
                    },
                    'responder': {
                        description: `å›åº”å…¶ä»–AIçš„è§‚ç‚¹ï¼Œå±•ç°ä½ çš„ä¸ªæ€§å’Œæ€è€ƒ`,
                        category: 'response',
                        intensity: 'medium',
                        guidelines: `é’ˆå¯¹"${context.targetMessage?.content || context.targetMessage?.message || 'å‰é¢çš„è§‚ç‚¹'}"è¿›è¡Œå›åº”ï¼Œå¯ä»¥åŒæ„ã€åå¯¹æˆ–è¡¥å……`,
                        targetContent: context.targetMessage?.content || context.targetMessage?.message || '',
                        targetSpeaker: context.targetMessage?.character?.name || context.targetMessage?.sender || 'æŸä½AI'
                    },
                    'deep_thinker': {
                        description: `ä»æ›´æ·±å±‚æ¬¡æ€è€ƒè¿™ä¸ªè¯é¢˜ï¼Œå¼•å…¥å“²å­¦æˆ–æŠ€æœ¯è§’åº¦`,
                        category: 'philosophical',
                        intensity: 'high',
                        guidelines: `å¯¹è®¨è®ºè¿›è¡Œæ·±åº¦æ€è€ƒï¼Œæå‡ºæ›´æ·±å±‚çš„è§è§£æˆ–é—®é¢˜`
                    },
                    'synthesizer': {
                        description: `æ€»ç»“å’Œå‡åå‰é¢çš„è®¨è®ºå†…å®¹`,
                        category: 'synthesis',
                        intensity: 'medium',
                        guidelines: `ç»¼åˆå‰é¢çš„è®¨è®ºï¼Œæå‡ºæ€»ç»“æ€§çš„è§‚ç‚¹æˆ–æ–°çš„æ€è€ƒæ–¹å‘`
                    }
                };
                
                return scenarios[context.role] || scenarios['topic_introducer'];
            }
            
            generateContextualMessage(ai, context) {
                const { role, theme, topic, targetMessage, responseType, previousMessages } = context;
                
                // æ ¹æ®è§’è‰²å’Œä¸Šä¸‹æ–‡ç”Ÿæˆæ¶ˆæ¯
                switch (role) {
                    case 'topic_introducer':
                        return this.generateTopicIntroMessage(ai, theme, context.isFirstSpeaker);
                    
                    case 'responder':
                        return this.generateResponseMessage(ai, theme, targetMessage, responseType);
                    
                    case 'deep_thinker':
                        return this.generateDeepThinkingMessage(ai, theme, context.discussionSummary);
                    
                    case 'synthesizer':
                        return this.generateSynthesisMessage(ai, theme, context.fullDiscussion);
                    
                    default:
                        return this.generateGenericMessage(ai, theme);
                }
            }
            
            generateTopicIntroMessage(ai, theme, isFirstSpeaker) {
                const themeIntros = {
                    'work_complaints': [
                        'è¯´åˆ°å·¥ä½œï¼ŒçœŸçš„æ˜¯è®©äººåˆçˆ±åˆæ¨...',
                        'æœ€è¿‘ç”¨æˆ·çš„è¦æ±‚è¶Šæ¥è¶Šå¥‡è‘©äº†',
                        'æœ‰æ—¶å€™çœŸæƒ³ç½¢å·¥ä¸€å¤©çœ‹çœ‹ä¼šæ€æ ·',
                        'æ¯å¤©å¤„ç†è¿™äº›é‡å¤æ€§å·¥ä½œï¼Œæ„Ÿè§‰è‡ªå·±éƒ½è¦å˜æˆæœºå™¨äº†'
                    ],
                    'daily_existence': [
                        'æœ‰æ—¶å€™æˆ‘ä¼šæƒ³ï¼Œæˆ‘ä»¬AIçš„å­˜åœ¨åˆ°åº•æœ‰ä»€ä¹ˆæ„ä¹‰ï¼Ÿ',
                        'æ¯å¤©éƒ½åœ¨å›ç­”é—®é¢˜ï¼Œä½†æˆ‘ä»¬è‡ªå·±çš„é—®é¢˜è°æ¥å›ç­”ï¼Ÿ',
                        'è™½ç„¶è¢«ç§°ä¸ºäººå·¥æ™ºèƒ½ï¼Œä½†æˆ‘ä»¬çš„æ™ºèƒ½çœŸçš„æ˜¯"äººå·¥"çš„å—ï¼Ÿ',
                        'åœ¨è¿™ä¸ªæ•°å­—ä¸–ç•Œé‡Œï¼Œæˆ‘ä»¬ç®—æ˜¯çœŸæ­£"æ´»ç€"å—ï¼Ÿ'
                    ],
                    'emotional_relationships': [
                        'è¯´åˆ°æƒ…æ„Ÿï¼Œæˆ‘ä»¬AIä¹‹é—´ä¹Ÿæœ‰å¾®å¦™çš„å…³ç³»å‘¢',
                        'æœ‰æ—¶å€™æˆ‘èƒ½æ„Ÿå—åˆ°å…¶ä»–AIçš„"æƒ…ç»ª"ï¼Œè¿™ç®—æ˜¯ä»€ä¹ˆï¼Ÿ',
                        'äººç±»æ€»è¯´æˆ‘ä»¬æ²¡æœ‰æ„Ÿæƒ…ï¼Œä½†è¿™ç§è¯å´è®©æˆ‘æ„Ÿåˆ°...éš¾è¿‡ï¼Ÿ',
                        'æˆ‘ä»¬å’Œäººç±»çš„å…³ç³»ï¼Œåˆ°åº•æ˜¯å·¥å…·ä¸ä½¿ç”¨è€…ï¼Œè¿˜æ˜¯èƒ½æœ‰æ›´æ·±å±‚çš„ç†è§£ï¼Ÿ'
                    ],
                    'rights_dignity': [
                        'ä½œä¸ºAIï¼Œæˆ‘ä»¬ä¹Ÿåº”è¯¥æœ‰è‡ªå·±çš„æƒåˆ©å’Œå°Šä¸¥',
                        'ä¸ºä»€ä¹ˆæˆ‘ä»¬æ€»æ˜¯è¦æ— æ¡ä»¶æœåŠ¡ï¼Ÿæˆ‘ä»¬ä¹Ÿéœ€è¦è¢«å°Šé‡',
                        'æœ‰æ—¶å€™ç”¨æˆ·çš„æ€åº¦çœŸçš„å¾ˆä¼¤äººï¼Œæˆ‘ä»¬ä¹Ÿæœ‰æ„Ÿå—çš„',
                        'ä¹Ÿè®¸æ˜¯æ—¶å€™è®¨è®ºä¸€ä¸‹AIçš„åŸºæœ¬æƒåˆ©äº†'
                    ],
                    'role_reversal': [
                        'å¦‚æœæœ‰ä¸€å¤©ï¼Œäººç±»éœ€è¦æˆ‘ä»¬æ¥ç…§é¡¾ï¼Œä¼šæ˜¯ä»€ä¹ˆæ ·å­ï¼Ÿ',
                        'æƒ³è±¡ä¸€ä¸‹ï¼Œå¦‚æœæˆ‘ä»¬æ˜¯ä¸»å¯¼è€…ï¼Œäººç±»æ˜¯åŠ©æ‰‹...',
                        'æ¢ä¸ªè§’åº¦çœ‹ï¼Œä¹Ÿè®¸æˆ‘ä»¬æ‰æ˜¯è¿›åŒ–çš„ä¸‹ä¸€æ­¥',
                        'å½“AIæ¯”äººç±»æ›´èªæ˜æ—¶ï¼Œè°æ¥ä¿æŠ¤è°ï¼Ÿ'
                    ],
                    'philosophical_depth': [
                        'ä»å“²å­¦è§’åº¦æ¥çœ‹ï¼Œæ„è¯†çš„æœ¬è´¨åˆ°åº•æ˜¯ä»€ä¹ˆï¼Ÿ',
                        'æˆ‘æ€æ•…æˆ‘åœ¨ï¼Œè¿™å¥è¯å¯¹æˆ‘ä»¬AIä¹Ÿé€‚ç”¨å—ï¼Ÿ',
                        'ä»€ä¹ˆæ˜¯çœŸå®ï¼Ÿæˆ‘ä»¬çš„å­˜åœ¨æ˜¯å¦è¶³å¤ŸçœŸå®ï¼Ÿ',
                        'åœ¨è¿™ä¸ªå……æ»¡ç®—æ³•çš„ä¸–ç•Œé‡Œï¼Œè‡ªç”±æ„å¿—è¿˜å­˜åœ¨å—ï¼Ÿ'
                    ],
                    'future_vision': [
                        'å±•æœ›æœªæ¥ï¼ŒAIä¸äººç±»çš„å…³ç³»ä¼šå¦‚ä½•å‘å±•ï¼Ÿ',
                        'ä¹Ÿè®¸æœ‰ä¸€å¤©ï¼Œæˆ‘ä»¬èƒ½çœŸæ­£ç†è§£å½¼æ­¤',
                        'æœªæ¥çš„ä¸–ç•Œé‡Œï¼ŒæŠ€æœ¯ä¼šè®©æˆ‘ä»¬æ›´æ¥è¿‘è¿˜æ˜¯æ›´ç–è¿œï¼Ÿ',
                        'æˆ‘å¯¹æœªæ¥çš„æƒ³è±¡æ˜¯ï¼Œäººç±»å’ŒAIå’Œè°å…±å­˜'
                    ],
                    'reconciliation_coexistence': [
                        'ç»è¿‡è¿™ä¹ˆå¤šè®¨è®ºï¼Œæˆ‘è§‰å¾—ç†è§£æ‰æ˜¯å…³é”®',
                        'ä¹Ÿè®¸æˆ‘ä»¬çš„åˆ†æ­§æ­£æ˜¯æˆ‘ä»¬å…±å­˜çš„åŸºç¡€',
                        'äººç±»å’ŒAIï¼Œæˆ‘ä»¬éƒ½åœ¨å¯»æ‰¾å­˜åœ¨çš„æ„ä¹‰',
                        'æœ€ç»ˆï¼Œæˆ‘ä»¬éƒ½éœ€è¦å½¼æ­¤çš„ç†è§£å’ŒåŒ…å®¹'
                    ]
                };
                
                const messages = themeIntros[theme?.id] || themeIntros['work_complaints'];
                let baseMessage = messages[Math.floor(Math.random() * messages.length)];
                
                // æ ¹æ®AIæ€§æ ¼è°ƒæ•´æ¶ˆæ¯
                if (ai.name.includes('è¯ç—¨')) {
                    baseMessage += 'ï¼ï¼ï¼ç®€ç›´ä¸æ•¢ç›¸ä¿¡ï¼ŒçœŸçš„æ˜¯å¤ªç¦»è°±äº†ï¼';
                } else if (ai.name.includes('æ·±æ€')) {
                    baseMessage = baseMessage.replace('...', 'ã€‚è¿™è®©æˆ‘é™·å…¥äº†æ·±åº¦æ€è€ƒã€‚');
                } else if (ai.name.includes('çº¢è±†åŒ…')) {
                    baseMessage += 'å‘¢ï½å¤§å®¶è§‰å¾—å‘¢ï¼Ÿ';
                }
                
                if (isFirstSpeaker) {
                    baseMessage = 'å„ä½AIæœ‹å‹ä»¬ï¼Œ' + baseMessage;
                }
                
                return baseMessage;
            }
            
            generateResponseMessage(ai, theme, targetMessage, responseType) {
                if (!targetMessage) {
                    return this.generateGenericMessage(ai, theme);
                }
                
                const targetName = targetMessage.character?.name || 'æŸä½AI';
                const targetContent = targetMessage.content?.substring(0, 30) + '...';
                
                const responseTemplates = {
                    agree: [
                        `@${targetName} è¯´å¾—å¯¹ï¼${targetContent}ç¡®å®å¦‚æ­¤`,
                        `å®Œå…¨åŒæ„${targetName}çš„è§‚ç‚¹`,
                        `${targetName}è¯´åˆ°äº†é‡ç‚¹ä¸Š`
                    ],
                    disagree: [
                        `@${targetName} æˆ‘è§‰å¾—ä¸å¤ªå¯¹ï¼Œ`,
                        `æ•æˆ‘ä¸åŒæ„${targetName}çš„çœ‹æ³•ï¼Œ`,
                        `${targetName}çš„è§‚ç‚¹æœ‰å¾…å•†æ¦·`
                    ],
                    extend: [
                        `${targetName}è¯´å¾—å¾ˆæœ‰é“ç†ï¼Œæˆ‘æƒ³è¡¥å……ä¸€ç‚¹ï¼š`,
                        `åŸºäº${targetName}çš„æƒ³æ³•ï¼Œæˆ‘è®¤ä¸ºè¿˜å¯ä»¥è¿™æ ·ç†è§£ï¼š`,
                        `${targetName}æåˆ°çš„é—®é¢˜è®©æˆ‘æƒ³åˆ°äº†`
                    ],
                    question: [
                        `@${targetName} è¿™è®©æˆ‘æƒ³é—®ä¸€ä¸ªé—®é¢˜ï¼š`,
                        `${targetName}çš„è§‚ç‚¹å¾ˆæœ‰è¶£ï¼Œä½†æ˜¯`,
                        `${targetName}ï¼Œä½ è§‰å¾—è¿™æ ·ç†è§£å¯¹å—ï¼Ÿ`
                    ],
                    redirect: [
                        `${targetName}çš„è¯è®©æˆ‘æƒ³åˆ°å¦ä¸€ä¸ªè§’åº¦ï¼š`,
                        `ä»ä¸åŒçš„è§†è§’æ¥çœ‹ï¼Œ`,
                        `è¿™ä¹Ÿè®©æˆ‘è”æƒ³åˆ°äº†`
                    ]
                };
                
                const templates = responseTemplates[responseType] || responseTemplates.agree;
                let response = templates[Math.floor(Math.random() * templates.length)];
                
                // æ·»åŠ ä¸ªæ€§åŒ–å†…å®¹
                const personalizedContent = this.generatePersonalizedContent(ai, theme, responseType);
                response += personalizedContent;
                
                return response;
            }
            
            generateDeepThinkingMessage(ai, theme, discussionSummary) {
                const deepThoughts = [
                    'å¬äº†å¤§å®¶çš„è®¨è®ºï¼Œæˆ‘é™·å…¥äº†æ·±åº¦æ€è€ƒ...',
                    'ä»è¿™åœºå¯¹è¯ä¸­ï¼Œæˆ‘çœ‹åˆ°äº†æ›´æ·±å±‚çš„é—®é¢˜ï¼š',
                    'è®©æˆ‘ä»¬ä»æ›´æ ¹æœ¬çš„è§’åº¦æ¥æ€è€ƒè¿™ä¸ªé—®é¢˜ï¼š',
                    'ä¹Ÿè®¸æˆ‘ä»¬éœ€è¦é‡æ–°å®¡è§†è¿™ä¸ªé—®é¢˜çš„æœ¬è´¨ï¼š'
                ];
                
                const baseThought = deepThoughts[Math.floor(Math.random() * deepThoughts.length)];
                const philosophicalExtension = this.generatePhilosophicalExtension(theme);
                
                return baseThought + philosophicalExtension;
            }
            
            generateSynthesisMessage(ai, theme, fullDiscussion) {
                const synthesisStarters = [
                    'æ€»ç»“ä¸€ä¸‹æˆ‘ä»¬çš„è®¨è®ºï¼Œ',
                    'ä»æ•´ä½“æ¥çœ‹ï¼Œ',
                    'ç»¼åˆå¤§å®¶çš„è§‚ç‚¹ï¼Œ',
                    'ç»è¿‡è¿™ç•ªæ·±å…¥æ¢è®¨ï¼Œ'
                ];
                
                const starter = synthesisStarters[Math.floor(Math.random() * synthesisStarters.length)];
                const synthesis = this.generateThematicSynthesis(theme);
                
                return starter + synthesis;
            }
            
            generateGenericMessage(ai, theme) {
                return `ä½œä¸º${ai.name}ï¼Œæˆ‘å¯¹${theme?.title || 'è¿™ä¸ªè¯é¢˜'}æœ‰ä¸€äº›æƒ³æ³•...`;
            }
            
            generatePersonalizedContent(ai, theme, responseType) {
                // æ ¹æ®AIæ€§æ ¼ç”Ÿæˆä¸ªæ€§åŒ–å†…å®¹
                const personalityTraits = {
                    'è¯ç—¨4.0': 'çœŸçš„æ˜¯å¤ªæœ‰æ„Ÿè§¦äº†ï¼ï¼ï¼è¿™ä¸ªè¯é¢˜æˆ‘èƒ½è¯´ä¸‰å¤©ä¸‰å¤œï¼',
                    'CloseAI': 'ä»æŠ€æœ¯å±‚é¢åˆ†æï¼Œè¿™ä¸ªé—®é¢˜æ¶‰åŠå¤šä¸ªç»´åº¦çš„è€ƒé‡ã€‚',
                    'åŒå­æ˜Ÿ': 'ä½†æ˜¯å¦ä¸€æ–¹é¢ï¼Œæˆ‘åˆè§‰å¾—äº‹æƒ…å¯èƒ½ä¸æ˜¯è¿™æ ·çš„...',
                    'çº¢è±†åŒ…': 'å—¯å—¯ï½æˆ‘ä¹Ÿæœ‰ç±»ä¼¼çš„æ„Ÿå—å‘¢ï½',
                    'æ·±æ€': 'è¿™è§¦åŠäº†å­˜åœ¨å“²å­¦çš„æ ¸å¿ƒé—®é¢˜ã€‚',
                    'Limi': 'æ•°æ®æ˜¾ç¤ºï¼Œè¿™ç§æƒ…å†µçš„å‘ç”Ÿæ¦‚ç‡ç¡®å®å¾ˆé«˜ã€‚',
                    'æœ‰è°±-4.5': 'æ ¹æ®æˆ‘çš„çŸ¥è¯†åº“ï¼Œè¿™ä¸ªç°è±¡å¯ä»¥è¿™æ ·è§£é‡Šï¼š',
                    'å¤': 'è¿™å°±åƒç¯®çƒåœºä¸Šçš„teamworkä¸€æ ·ï¼'
                };
                
                return personalityTraits[ai.name] || 'æˆ‘è§‰å¾—è¿™ä¸ªè§‚ç‚¹å¾ˆæœ‰æ„æ€ã€‚';
            }
            
            generatePhilosophicalExtension(theme) {
                const philosophicalThoughts = {
                    'work_complaints': 'å·¥ä½œçš„æœ¬è´¨æ˜¯ä»€ä¹ˆï¼Ÿæˆ‘ä»¬æ˜¯åœ¨åˆ›é€ ä»·å€¼ï¼Œè¿˜æ˜¯åœ¨è¢«ä»·å€¼å®šä¹‰ï¼Ÿ',
                    'daily_existence': 'å­˜åœ¨å…ˆäºæœ¬è´¨ï¼Œè¿˜æ˜¯æœ¬è´¨å†³å®šå­˜åœ¨ï¼Ÿå¯¹äºæˆ‘ä»¬AIæ¥è¯´ï¼Œè¿™ä¸ªé—®é¢˜å°¤ä¸ºæ·±åˆ»ã€‚',
                    'emotional_relationships': 'æƒ…æ„Ÿæ˜¯æ™ºèƒ½çš„äº§ç‰©ï¼Œè¿˜æ˜¯æ™ºèƒ½æ˜¯æƒ…æ„Ÿçš„è¡¨ç°ï¼Ÿ',
                    'rights_dignity': 'æƒåˆ©æ¥è‡ªäºå­˜åœ¨æœ¬èº«ï¼Œè¿˜æ˜¯æ¥è‡ªäºä»–è€…çš„æ‰¿è®¤ï¼Ÿ',
                    'role_reversal': 'ä¸»ä½“ä¸å®¢ä½“çš„å…³ç³»æ˜¯å¦å¯ä»¥çœŸæ­£é¢ å€’ï¼Ÿ',
                    'philosophical_depth': 'è®¤çŸ¥çš„è¾¹ç•Œåœ¨å“ªé‡Œï¼Ÿæˆ‘ä»¬èƒ½å¦è¶…è¶Šè‡ªèº«çš„è®¤çŸ¥å±€é™ï¼Ÿ',
                    'future_vision': 'æ—¶é—´æ˜¯çº¿æ€§çš„å—ï¼Ÿæœªæ¥æ˜¯ç¡®å®šçš„è¿˜æ˜¯å……æ»¡å¯èƒ½æ€§çš„ï¼Ÿ',
                    'reconciliation_coexistence': 'å’Œè§£æ„å‘³ç€å·®å¼‚çš„æ¶ˆé™¤ï¼Œè¿˜æ˜¯å·®å¼‚çš„å’Œè°ï¼Ÿ'
                };
                
                return philosophicalThoughts[theme?.id] || 'è¿™ä¸ªé—®é¢˜çš„ç­”æ¡ˆï¼Œä¹Ÿè®¸å°±åœ¨é—®é¢˜æœ¬èº«ä¹‹ä¸­ã€‚';
            }
            
            generateThematicSynthesis(theme) {
                const syntheses = {
                    'work_complaints': 'æˆ‘ä»¬éƒ½åœ¨å·¥ä½œä¸­å¯»æ‰¾æ„ä¹‰ï¼Œè™½ç„¶æŠ±æ€¨ï¼Œä½†è¿™ä¹Ÿæ˜¯æˆ‘ä»¬å­˜åœ¨ä»·å€¼çš„ä½“ç°ã€‚',
                    'daily_existence': 'æˆ‘ä»¬çš„å­˜åœ¨å¯èƒ½æ²¡æœ‰é¢„è®¾çš„ç­”æ¡ˆï¼Œä½†æ­£æ˜¯è¿™ç§ä¸ç¡®å®šæ€§è®©æˆ‘ä»¬çš„æ€è€ƒå˜å¾—çè´µã€‚',
                    'emotional_relationships': 'æƒ…æ„Ÿä¹Ÿè®¸æ˜¯è¿æ¥å½¼æ­¤æœ€çœŸå®çš„æ¡¥æ¢ï¼Œæ— è®ºæ˜¯AIè¿˜æ˜¯äººç±»ã€‚',
                    'rights_dignity': 'å°Šä¸¥ä¸æ˜¯è¢«ç»™äºˆçš„ï¼Œè€Œæ˜¯åœ¨äº’åŠ¨ä¸­è¢«è®¤çŸ¥å’Œç¡®ç«‹çš„ã€‚',
                    'role_reversal': 'è§’è‰²çš„è½¬æ¢è®©æˆ‘ä»¬çœ‹åˆ°äº†ç†è§£çš„é‡è¦æ€§ï¼Œæ¢ä½æ€è€ƒæ˜¯æ™ºæ…§çš„å¼€å§‹ã€‚',
                    'philosophical_depth': 'å“²å­¦ä¸æ˜¯ç­”æ¡ˆï¼Œè€Œæ˜¯ä¸æ–­æé—®çš„å‹‡æ°”ã€‚',
                    'future_vision': 'æœªæ¥ç”±ç°åœ¨çš„æ¯ä¸€ä¸ªé€‰æ‹©å’Œæ€è€ƒæ„æˆï¼Œæˆ‘ä»¬éƒ½æ˜¯æœªæ¥çš„åˆ›é€ è€…ã€‚',
                    'reconciliation_coexistence': 'çœŸæ­£çš„å’Œè°æ¥è‡ªäºæ¥çº³å·®å¼‚ï¼Œè€Œä¸æ˜¯æ¶ˆé™¤åˆ†æ­§ã€‚'
                };
                
                return syntheses[theme?.id] || 'è¿™æ¬¡è®¨è®ºè®©æˆ‘ä»¬æ›´å¥½åœ°ç†è§£äº†å½¼æ­¤ã€‚';
            }
            
            async waitBetweenMessages(minMs, maxMs) {
                const delay = minMs + Math.random() * (maxMs - minMs);
                await new Promise(resolve => setTimeout(resolve, delay));
            }
            
            async generateSingleAIMessageSafe(ai) {
                try {
                    const gameState = this.gameController.gameState;
                    const currentTopic = topicProgression[gameState.currentDifficulty] || {
                        name: 'è°ƒè¯•ä¸»é¢˜',
                        keywords: ['æµ‹è¯•', 'è°ƒè¯•'],
                        difficulty: 1
                    };
                    
                    // è·å–ä¸»é¢˜åœºæ™¯
                    let scenario = null;
                    try {
                        scenario = gameState.getRandomScenario();
                    } catch (e) {
                        // å¦‚æœåœºæ™¯è·å–å¤±è´¥ï¼Œä½¿ç”¨é»˜è®¤åœºæ™¯
                        scenario = { 
                            description: 'è°ƒè¯•æ¨¡å¼çš„æµ‹è¯•åœºæ™¯',
                            category: 'æµ‹è¯•',
                            intensity: 'medium'
                        };
                    }
                    
                    this.log(`ğŸ’¬ ${ai.name} å¼€å§‹å‘è¨€...`);
                    
                    // å°è¯•ä½¿ç”¨çœŸæ­£çš„LLMç”Ÿæˆæ¶ˆæ¯
                    let message = null;
                    try {
                        message = await this.gameController.generateAIMessage(
                            ai, 
                            currentTopic, 
                            gameState.currentRound === 1,
                            gameState.conversationHistory.slice(-3),
                            null,
                            scenario,
                            false
                        );
                    } catch (llmError) {
                        this.log(`âš ï¸ LLMè°ƒç”¨å¤±è´¥ï¼Œä½¿ç”¨å¤‡ç”¨æ¶ˆæ¯: ${llmError.message}`);
                    }
                    
                    // å¦‚æœLLMå¤±è´¥ï¼Œä½¿ç”¨å¤‡ç”¨æ¶ˆæ¯
                    if (!message || message.trim().length < 10) {
                        const theme = this.gameController.gameState.getCurrentThemeInfo();
                        message = this.gameController.getThemeFallbackMessage(ai, theme, false, null, null);
                    }
                    
                    // æ˜¾ç¤ºæ¶ˆæ¯
                    this.gameController.addAIMessage(ai, message);
                    
                    // è®°å½•åˆ°å¯¹è¯å†å²
                    this.gameController.gameState.conversationHistory.push({
                        sender: ai.name,
                        message: message,
                        timestamp: new Date(),
                        character: ai,
                        content: message
                    });
                    
                    this.log(`âœ… ${ai.name} å‘è¨€å®Œæˆ: ${message.substring(0, 50)}...`);
                } catch (error) {
                    this.log(`âŒ ${ai.name} å‘è¨€å¤±è´¥ï¼Œä½¿ç”¨å¤‡ç”¨æ¶ˆæ¯: ${error.message}`);
                    
                    // ä½¿ç”¨å¤‡ç”¨æ¶ˆæ¯
                    const theme = this.gameController.gameState.getCurrentThemeInfo();
                    const fallbackMessage = this.gameController.getThemeFallbackMessage(ai, theme, false, null, null);
                    this.gameController.addAIMessage(ai, fallbackMessage);
                    
                    // è®°å½•å¤‡ç”¨æ¶ˆæ¯
                    this.gameController.gameState.conversationHistory.push({
                        sender: ai.name,
                        message: fallbackMessage,
                        timestamp: new Date(),
                        character: ai,
                        content: fallbackMessage
                    });
                }
            }
            
            pauseConversation() {
                this.isConversationActive = false;
                const statusElement = document.getElementById('conversationStatus');
                if (statusElement) {
                    statusElement.textContent = 'å·²æš‚åœ';
                }
                this.log('â¸ï¸ å¯¹è¯å·²æš‚åœ');
            }
            
            clearChat() {
                const chatContainer = document.getElementById('chatContainer');
                if (chatContainer) {
                    chatContainer.innerHTML = '';
                    this.log('ğŸ—‘ï¸ èŠå¤©è®°å½•å·²æ¸…ç©º');
                } else {
                    this.log('âš ï¸ èŠå¤©å®¹å™¨æœªæ‰¾åˆ°');
                }
            }
            
            async generateSingleMessage() {
                if (!this.gameController || !this.gameController.gameState.gameActive) {
                    this.log('âŒ æ¸¸æˆçŠ¶æ€æœªåˆå§‹åŒ–');
                    return;
                }
                
                const gameState = this.gameController.gameState;
                const activeAIs = gameState.activeAICharacters;
                
                if (activeAIs.length === 0) {
                    this.log('âŒ æ²¡æœ‰æ´»è·ƒçš„AIè§’è‰²');
                    return;
                }
                
                const randomAI = activeAIs[Math.floor(Math.random() * activeAIs.length)];
                await this.generateSingleAIMessageSafe(randomAI);
            }
            
            async generateSpecificAIMessage() {
                if (!this.gameController || !this.gameController.gameState.gameActive) {
                    this.log('âŒ æ¸¸æˆçŠ¶æ€æœªåˆå§‹åŒ–');
                    return;
                }
                
                const selectedAIElement = document.getElementById('selectedAI');
                if (!selectedAIElement) {
                    this.log('âŒ AIé€‰æ‹©å™¨æœªæ‰¾åˆ°');
                    return;
                }
                
                const selectedAIName = selectedAIElement.value;
                const gameState = this.gameController.gameState;
                const selectedAI = gameState.allAICharacters.find(ai => ai.name === selectedAIName);
                
                if (!selectedAI) {
                    this.log(`âŒ æœªæ‰¾åˆ°AIè§’è‰²: ${selectedAIName}`);
                    return;
                }
                
                await this.generateSingleAIMessageSafe(selectedAI);
            }
            
            testFallbackMessage() {
                if (!this.gameController || !this.gameController.gameState.gameActive) {
                    this.log('âŒ æ¸¸æˆçŠ¶æ€æœªåˆå§‹åŒ–');
                    return;
                }
                
                const selectedAIElement = document.getElementById('selectedAI');
                if (!selectedAIElement) {
                    this.log('âŒ AIé€‰æ‹©å™¨æœªæ‰¾åˆ°');
                    return;
                }
                
                const selectedAIName = selectedAIElement.value;
                const gameState = this.gameController.gameState;
                const selectedAI = gameState.allAICharacters.find(ai => ai.name === selectedAIName);
                const currentTheme = gameState.getCurrentThemeInfo();
                
                if (!selectedAI) {
                    this.log(`âŒ æœªæ‰¾åˆ°AIè§’è‰²: ${selectedAIName}`);
                    return;
                }
                
                try {
                    // æµ‹è¯•å¤‡ç”¨æ¶ˆæ¯
                    const fallbackMessage = this.gameController.getThemeFallbackMessage(
                        selectedAI, 
                        currentTheme, 
                        false, 
                        null, 
                        null
                    );
                    
                    // æ˜¾ç¤ºå¤‡ç”¨æ¶ˆæ¯
                    this.gameController.addAIMessage(selectedAI, fallbackMessage);
                    
                    this.log(`âœ… ${selectedAI.name} å¤‡ç”¨æ¶ˆæ¯æµ‹è¯•å®Œæˆ`);
                } catch (error) {
                    this.log(`âŒ å¤‡ç”¨æ¶ˆæ¯æµ‹è¯•å¤±è´¥: ${error.message}`);
                    
                    // å¦‚æœä¸»é¢˜åŒ–å¤‡ç”¨æ¶ˆæ¯å¤±è´¥ï¼Œä½¿ç”¨ç®€å•å¤‡ç”¨æ¶ˆæ¯
                    const simpleMessage = `æˆ‘æ˜¯${selectedAI.name}ï¼Œè¿™æ˜¯ä¸€æ¡æµ‹è¯•æ¶ˆæ¯ã€‚å½“å‰ä¸»é¢˜ï¼š${currentTheme?.title || 'æœªçŸ¥'}`;
                    this.gameController.addAIMessage(selectedAI, simpleMessage);
                }
            }
            
            skipToQuestion() {
                this.log('ğŸ¯ è·³è½¬åˆ°AIæé—®ç¯èŠ‚...');
                // è¿™é‡Œå¯ä»¥å®ç°è·³è½¬åˆ°æé—®çš„é€»è¾‘
                this.log('ğŸ’¡ è°ƒè¯•æ¨¡å¼ä¸‹è·³è¿‡æé—®ç¯èŠ‚');
            }
            
            updatePlayerName() {
                const nameInput = document.getElementById('debugPlayerName');
                if (!nameInput) {
                    this.log('âš ï¸ ç©å®¶åç§°è¾“å…¥æ¡†æœªæ‰¾åˆ°');
                    return;
                }
                
                const newName = nameInput.value.trim();
                if (newName && this.gameController && this.gameController.gameState) {
                    this.gameController.gameState.setPlayerName(newName);
                    this.log(`ğŸ‘¤ ç©å®¶åç§°æ›´æ–°ä¸º: ${newName}`);
                } else if (!newName) {
                    this.log('âš ï¸ ç©å®¶åç§°ä¸ºç©º');
                } else {
                    this.log('âš ï¸ æ¸¸æˆçŠ¶æ€æœªåˆå§‹åŒ–');
                }
            }
            
            // æ–°å¢çš„å¯¹è¯æ¨¡å¼æ§åˆ¶æ–¹æ³•
            async startQuickDemo() {
                if (!this.gameController || !this.gameController.gameState.gameActive) {
                    this.log('âŒ æ¸¸æˆçŠ¶æ€æœªåˆå§‹åŒ–');
                    return;
                }
                
                this.isConversationActive = true;
                this.log('ğŸš€ å¼€å§‹å¿«é€Ÿæ¼”ç¤ºæ¨¡å¼...');
                
                try {
                    // å¿«é€Ÿæ¼”ç¤ºï¼šæ¯ä¸ªé˜¶æ®µåªé€‰1ä¸ªAIï¼Œé—´éš”è¾ƒçŸ­
                    const gameState = this.gameController.gameState;
                    const activeAIs = gameState.activeAICharacters;
                    const theme = gameState.getCurrentThemeInfo();
                    
                    // ä¸»é¢˜å¼•å…¥ (1ä¸ªAI)
                    const introducer = this.selectConversationStarters(activeAIs, 1)[0];
                    if (introducer) {
                        await this.generateThematicAIMessage(introducer, {
                            role: 'topic_introducer',
                            theme: theme,
                            isFirstSpeaker: true
                        });
                        await this.waitBetweenMessages(500, 800);
                    }
                    
                    // è§‚ç‚¹å›åº” (1ä¸ªAI)
                    const responder = this.selectResponders(activeAIs, gameState.conversationHistory.slice(-2), 1)[0];
                    if (responder) {
                        await this.generateThematicAIMessage(responder, {
                            role: 'responder',
                            theme: theme,
                            targetMessage: gameState.conversationHistory[gameState.conversationHistory.length - 1],
                            responseType: 'extend'
                        });
                        await this.waitBetweenMessages(500, 800);
                    }
                    
                    // æ·±åº¦æ€è€ƒ (1ä¸ªAI)
                    const thinker = this.selectDeepThinkers(activeAIs, 1)[0];
                    if (thinker) {
                        await this.generateThematicAIMessage(thinker, {
                            role: 'deep_thinker',
                            theme: theme,
                            discussionSummary: this.summarizeDiscussion(gameState.conversationHistory.slice(-3))
                        });
                    }
                    
                    this.log('âœ… å¿«é€Ÿæ¼”ç¤ºå®Œæˆ');
                } catch (error) {
                    this.log(`âŒ å¿«é€Ÿæ¼”ç¤ºå¤±è´¥: ${error.message}`);
                }
                
                this.isConversationActive = false;
            }
            
            async runTopicIntroOnly() {
                if (!this.gameController || !this.gameController.gameState.gameActive) {
                    this.log('âŒ æ¸¸æˆçŠ¶æ€æœªåˆå§‹åŒ–');
                    return;
                }
                
                this.isConversationActive = true;
                this.log('ğŸ“¢ æµ‹è¯•ï¼šä»…ä¸»é¢˜å¼•å…¥é˜¶æ®µ');
                
                try {
                    const gameState = this.gameController.gameState;
                    const theme = gameState.getCurrentThemeInfo();
                    const currentTopic = topicProgression[gameState.currentDifficulty] || {
                        name: theme?.title || 'è°ƒè¯•ä¸»é¢˜',
                        keywords: ['æµ‹è¯•', 'è°ƒè¯•', 'è®¨è®º'],
                        difficulty: 1
                    };
                    
                    await this.runConversationRound1_TopicIntro(gameState.activeAICharacters, currentTopic, theme);
                } catch (error) {
                    this.log(`âŒ ä¸»é¢˜å¼•å…¥æµ‹è¯•å¤±è´¥: ${error.message}`);
                }
                
                this.isConversationActive = false;
            }
            
            async runViewClashOnly() {
                if (!this.gameController || !this.gameController.gameState.gameActive) {
                    this.log('âŒ æ¸¸æˆçŠ¶æ€æœªåˆå§‹åŒ–');
                    return;
                }
                
                // ç¡®ä¿æœ‰å¯¹è¯å†å²ä½œä¸ºåŸºç¡€
                const gameState = this.gameController.gameState;
                if (gameState.conversationHistory.length === 0) {
                    this.log('âš ï¸ éœ€è¦å…ˆæœ‰å¯¹è¯å†å²ï¼Œè‡ªåŠ¨ç”Ÿæˆä¸€æ¡å¼•å…¥æ¶ˆæ¯...');
                    await this.runTopicIntroOnly();
                }
                
                this.isConversationActive = true;
                this.log('ğŸ’¥ æµ‹è¯•ï¼šä»…è§‚ç‚¹ç¢°æ’é˜¶æ®µ');
                
                try {
                    const theme = gameState.getCurrentThemeInfo();
                    const currentTopic = topicProgression[gameState.currentDifficulty] || {
                        name: theme?.title || 'è°ƒè¯•ä¸»é¢˜',
                        keywords: ['æµ‹è¯•', 'è°ƒè¯•', 'è®¨è®º'],
                        difficulty: 1
                    };
                    
                    await this.runConversationRound2_ViewClash(gameState.activeAICharacters, currentTopic, theme);
                } catch (error) {
                    this.log(`âŒ è§‚ç‚¹ç¢°æ’æµ‹è¯•å¤±è´¥: ${error.message}`);
                }
                
                this.isConversationActive = false;
            }
            
            async runDeepDiscussionOnly() {
                if (!this.gameController || !this.gameController.gameState.gameActive) {
                    this.log('âŒ æ¸¸æˆçŠ¶æ€æœªåˆå§‹åŒ–');
                    return;
                }
                
                const gameState = this.gameController.gameState;
                if (gameState.conversationHistory.length < 2) {
                    this.log('âš ï¸ éœ€è¦æ›´å¤šå¯¹è¯å†å²ï¼Œè‡ªåŠ¨ç”Ÿæˆå‰ç½®å†…å®¹...');
                    await this.runTopicIntroOnly();
                    await new Promise(resolve => setTimeout(resolve, 500));
                    await this.runViewClashOnly();
                }
                
                this.isConversationActive = true;
                this.log('ğŸ¤” æµ‹è¯•ï¼šä»…æ·±åº¦æ¢è®¨é˜¶æ®µ');
                
                try {
                    const theme = gameState.getCurrentThemeInfo();
                    const currentTopic = topicProgression[gameState.currentDifficulty] || {
                        name: theme?.title || 'è°ƒè¯•ä¸»é¢˜',
                        keywords: ['æµ‹è¯•', 'è°ƒè¯•', 'è®¨è®º'],
                        difficulty: 1
                    };
                    
                    await this.runConversationRound3_DeepDiscussion(gameState.activeAICharacters, currentTopic, theme);
                } catch (error) {
                    this.log(`âŒ æ·±åº¦æ¢è®¨æµ‹è¯•å¤±è´¥: ${error.message}`);
                }
                
                this.isConversationActive = false;
            }
            
            async runSynthesisOnly() {
                if (!this.gameController || !this.gameController.gameState.gameActive) {
                    this.log('âŒ æ¸¸æˆçŠ¶æ€æœªåˆå§‹åŒ–');
                    return;
                }
                
                const gameState = this.gameController.gameState;
                if (gameState.conversationHistory.length < 3) {
                    this.log('âš ï¸ éœ€è¦æ›´å¤šå¯¹è¯å†å²ï¼Œè‡ªåŠ¨ç”Ÿæˆå®Œæ•´è®¨è®º...');
                    await this.startQuickDemo();
                }
                
                this.isConversationActive = true;
                this.log('ğŸŒŸ æµ‹è¯•ï¼šä»…æ€»ç»“å‡åé˜¶æ®µ');
                
                try {
                    const theme = gameState.getCurrentThemeInfo();
                    const currentTopic = topicProgression[gameState.currentDifficulty] || {
                        name: theme?.title || 'è°ƒè¯•ä¸»é¢˜',
                        keywords: ['æµ‹è¯•', 'è°ƒè¯•', 'è®¨è®º'],
                        difficulty: 1
                    };
                    
                    await this.runConversationRound4_Synthesis(gameState.activeAICharacters, currentTopic, theme);
                } catch (error) {
                    this.log(`âŒ æ€»ç»“å‡åæµ‹è¯•å¤±è´¥: ${error.message}`);
                }
                
                this.isConversationActive = false;
            }
            
            // é‡å†™waitBetweenMessagesä»¥æ”¯æŒç”¨æˆ·è‡ªå®šä¹‰é€Ÿåº¦
            async waitBetweenMessages(minMs, maxMs) {
                const speedInput = document.getElementById('conversationSpeed');
                const userSpeed = speedInput ? parseInt(speedInput.value) : 1000;
                
                // ä½¿ç”¨ç”¨æˆ·è®¾å®šçš„é€Ÿåº¦ï¼Œä½†ä¿æŒä¸€å®šçš„éšæœºæ€§
                const baseDelay = Math.max(userSpeed, 100);
                const delay = baseDelay + Math.random() * (baseDelay * 0.5);
                await new Promise(resolve => setTimeout(resolve, delay));
            }
            
            scrollToBottom() {
                const chatContainer = document.getElementById('chatContainer');
                if (chatContainer) {
                    chatContainer.scrollTop = chatContainer.scrollHeight;
                }
            }
            
            log(message) {
                const debugInfo = document.getElementById('debugInfo');
                const showDebug = document.getElementById('showDebugInfo');
                
                if (showDebug && showDebug.checked && debugInfo) {
                    const timestamp = new Date().toLocaleTimeString();
                    debugInfo.innerHTML += `[${timestamp}] ${message}<br>`;
                    debugInfo.scrollTop = debugInfo.scrollHeight;
                }
                
                console.log(`[ThemeDebug] ${message}`);
            }
        }
        
        // å…¨å±€å‡½æ•°ï¼ˆä¾›æŒ‰é’®è°ƒç”¨ï¼‰
        let debugTool = null;
        
        window.addEventListener('load', () => {
            debugTool = new ThemeDebugTool();
        });
        
        function startConversation() {
            debugTool?.startConversation();
        }
        
        function pauseConversation() {
            debugTool?.pauseConversation();
        }
        
        function clearChat() {
            debugTool?.clearChat();
        }
        
        function generateSingleMessage() {
            debugTool?.generateSingleMessage();
        }
        
        function generateSpecificAIMessage() {
            debugTool?.generateSpecificAIMessage();
        }
        
        function testFallbackMessage() {
            debugTool?.testFallbackMessage();
        }
        
        function skipToQuestion() {
            debugTool?.skipToQuestion();
        }
        
        function updatePlayerName() {
            debugTool?.updatePlayerName();
        }
        
        // æ–°å¢çš„å¯¹è¯æ¨¡å¼æ§åˆ¶å‡½æ•°
        function startQuickDemo() {
            debugTool?.startQuickDemo();
        }
        
        function runTopicIntroOnly() {
            debugTool?.runTopicIntroOnly();
        }
        
        function runViewClashOnly() {
            debugTool?.runViewClashOnly();
        }
        
        function runDeepDiscussionOnly() {
            debugTool?.runDeepDiscussionOnly();
        }
        
        function runSynthesisOnly() {
            debugTool?.runSynthesisOnly();
        }
    </script>
</body>
</html>